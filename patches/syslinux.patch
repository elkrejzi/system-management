diff -Naur a/com32/lib/syslinux/disk.c b/com32/lib/syslinux/disk.c
--- a/com32/lib/syslinux/disk.c	2013-10-13 19:59:03.000000000 +0200
+++ b/com32/lib/syslinux/disk.c	2013-12-28 03:44:04.616528538 +0100
@@ -171,22 +171,28 @@
 static void *ebios_setup(const struct disk_info *const diskinfo, com32sys_t *inreg,
 			 uint64_t lba, uint8_t count, uint8_t op_code)
 {
-    static __lowmem struct disk_ebios_dapa dapa;
+    static struct disk_ebios_dapa *dapa = NULL;
     void *buf;
 
+    if (!dapa) {
+	dapa = lmalloc(sizeof *dapa);
+	if (!dapa)
+	    return NULL;
+    }
+
     buf = lmalloc(count * diskinfo->bps);
     if (!buf)
 	return NULL;
 
-    dapa.len = sizeof(dapa);
-    dapa.count = count;
-    dapa.off = OFFS(buf);
-    dapa.seg = SEG(buf);
-    dapa.lba = lba;
+    dapa->len = sizeof(*dapa);
+    dapa->count = count;
+    dapa->off = OFFS(buf);
+    dapa->seg = SEG(buf);
+    dapa->lba = lba;
 
     inreg->eax.b[1] = op_code;
-    inreg->esi.w[0] = OFFS(&dapa);
-    inreg->ds = SEG(&dapa);
+    inreg->esi.w[0] = OFFS(dapa);
+    inreg->ds = SEG(dapa);
     inreg->edx.b[0] = diskinfo->disk;
 
     return buf;
diff -Naur a/core/isolinux.asm b/core/isolinux.asm
--- a/core/isolinux.asm	2013-10-13 19:59:03.000000000 +0200
+++ b/core/isolinux.asm	2013-12-28 03:43:49.429256812 +0100
@@ -420,7 +420,7 @@
 		call getlinsec
 		pop eax
 		pop cx
-		mov dx,cx
+		movzx edx,cx
 		pop bp
 		pop bx
 
diff -Naur a/efi/i386/syslinux.ld b/efi/i386/syslinux.ld
--- a/efi/i386/syslinux.ld	2013-10-13 19:59:03.000000000 +0200
+++ b/efi/i386/syslinux.ld	2013-12-28 03:44:14.949713427 +0100
@@ -136,7 +136,7 @@
 		*(.strtab)
 	}
 
-	.bss : {
+	.bss (NOLOAD) : {
 		/* the EFI loader doesn't seem to like a .bss section,
 		   so we stick it all into .data: */
 		__bss_start = .;
@@ -153,7 +153,7 @@
 	__bss_dwords = (__bss_len + 3) >> 2;
 
 	. = ALIGN(128);
-	
+
 	/* Very large objects which don't need to be zeroed */
 
 	.hugebss : {
diff -Naur a/efi/wrapper.c b/efi/wrapper.c
--- a/efi/wrapper.c	2013-10-13 19:59:03.000000000 +0200
+++ b/efi/wrapper.c	2013-12-28 03:44:14.950713446 +0100
@@ -35,7 +35,7 @@
 #endif
 
 /*
- * 'so_size' is the file size of the ELF shared object.
+ * 'so_memsz' is the size of the ELF shared object once loaded.
  * 'data_size' is the size of initialised data in the shared object.
  *  'class' dictates how the header is written
  * 	For 32bit machines (class == ELFCLASS32), the optional
@@ -44,21 +44,23 @@
  * 	header includes PE32+header fields
  */
 static void write_header(FILE *f, __uint32_t entry, size_t data_size,
-			 __uint32_t so_size, __uint8_t class)
+			 __uint32_t so_memsz, __uint8_t class)
 {
 	struct optional_hdr o_hdr;
 	struct optional_hdr_pe32p o_hdr_pe32p;
-	struct section t_sec, r_sec;
+	struct section t_sec;
 	struct extra_hdr e_hdr;
 	struct extra_hdr_pe32p e_hdr_pe32p;
 	struct coff_hdr c_hdr;
 	struct header hdr;
-	struct coff_reloc c_rel;
-	__uint32_t total_sz = so_size;
-	__uint32_t dummy = 0;
+	__uint32_t total_sz = data_size;
 	__uint32_t hdr_sz;
 	__uint32_t reloc_start, reloc_end;
 
+	hdr_sz = 512;
+	total_sz += hdr_sz;
+	entry += hdr_sz;
+
 	memset(&hdr, 0, sizeof(hdr));
 	hdr.msdos_signature = MSDOS_SIGNATURE;
 
@@ -74,14 +76,9 @@
 	fwrite(&hdr, sizeof(hdr), 1, f);
 
 	memset(&c_hdr, 0, sizeof(c_hdr));
-	c_hdr.nr_sections = 2;
+	c_hdr.nr_sections = 1;
 	c_hdr.nr_syms = 1;
 	if (class == ELFCLASS32) {
-		hdr_sz = sizeof(o_hdr) + sizeof(t_sec) + sizeof(e_hdr) +
-				sizeof(r_sec) + sizeof(c_hdr) + sizeof(hdr) + sizeof(c_rel)
-				+ sizeof(dummy);
-		total_sz += hdr_sz;
-		entry += hdr_sz;
 		c_hdr.arch = IMAGE_FILE_MACHINE_I386;
 		c_hdr.characteristics = IMAGE_FILE_32BIT_MACHINE |
 			IMAGE_FILE_DEBUG_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE |
@@ -92,25 +89,20 @@
 		o_hdr.format = PE32_FORMAT;
 		o_hdr.major_linker_version = 0x02;
 		o_hdr.minor_linker_version = 0x14;
-		o_hdr.code_sz = total_sz;
+		o_hdr.code_sz = data_size;
 		o_hdr.entry_point = entry;
 		o_hdr.initialized_data_sz = data_size;
 		fwrite(&o_hdr, sizeof(o_hdr), 1, f);
 		memset(&e_hdr, 0, sizeof(e_hdr));
 		e_hdr.section_align = 4096;
 		e_hdr.file_align = 512;
-		e_hdr.image_sz = total_sz;
-		e_hdr.headers_sz = 512;
+		e_hdr.image_sz = hdr_sz + so_memsz;
+		e_hdr.headers_sz = hdr_sz;
 		e_hdr.subsystem = IMAGE_SUBSYSTEM_EFI_APPLICATION;
-		e_hdr.rva_and_sizes_nr = 1;
+		e_hdr.rva_and_sizes_nr = sizeof(e_hdr.data_directory) / sizeof(__uint64_t);
 		fwrite(&e_hdr, sizeof(e_hdr), 1, f);
 	}
 	else if (class == ELFCLASS64) {
-		hdr_sz = sizeof(o_hdr_pe32p) + sizeof(t_sec) + sizeof(e_hdr_pe32p) +
-				sizeof(r_sec) + sizeof(c_hdr) + sizeof(hdr) + sizeof(c_rel)
-				+ sizeof(dummy);
-		total_sz += hdr_sz;
-		entry += hdr_sz;
 		c_hdr.arch = IMAGE_FILE_MACHINE_X86_64;
 		c_hdr.characteristics = IMAGE_FILE_DEBUG_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE |
 			IMAGE_FILE_LINE_NUMBERS_STRIPPED;
@@ -120,49 +112,41 @@
 		o_hdr_pe32p.format = PE32P_FORMAT;
 		o_hdr_pe32p.major_linker_version = 0x02;
 		o_hdr_pe32p.minor_linker_version = 0x14;
-		o_hdr_pe32p.code_sz = total_sz;
+		o_hdr_pe32p.code_sz = data_size;
 		o_hdr_pe32p.entry_point = entry;
 		o_hdr.initialized_data_sz = data_size;
 		fwrite(&o_hdr_pe32p, sizeof(o_hdr_pe32p), 1, f);
-		memset(&e_hdr_pe32p, 0, sizeof(e_hdr));
+		memset(&e_hdr_pe32p, 0, sizeof(e_hdr_pe32p));
 		e_hdr_pe32p.section_align = 4096;
 		e_hdr_pe32p.file_align = 512;
-		e_hdr_pe32p.image_sz = total_sz;
-		e_hdr_pe32p.headers_sz = 512;
+		e_hdr_pe32p.image_sz = hdr_sz + so_memsz;
+		e_hdr_pe32p.headers_sz = hdr_sz;
 		e_hdr_pe32p.subsystem = IMAGE_SUBSYSTEM_EFI_APPLICATION;
-		e_hdr_pe32p.rva_and_sizes_nr = 1;
+		e_hdr_pe32p.rva_and_sizes_nr = sizeof(e_hdr_pe32p.data_directory) / sizeof(__uint64_t);
 		fwrite(&e_hdr_pe32p, sizeof(e_hdr_pe32p), 1, f);
 	}
 
 	memset(&t_sec, 0, sizeof(t_sec));
 	strcpy((char *)t_sec.name, ".text");
-	t_sec.virtual_sz = total_sz;
-	t_sec.raw_data_sz = total_sz;
+	t_sec.virtual_sz = data_size;
+	t_sec.virtual_address = hdr_sz;
+	t_sec.raw_data_sz = t_sec.virtual_sz;
+	t_sec.raw_data = t_sec.virtual_address;
 	t_sec.characteristics = IMAGE_SCN_CNT_CODE |
 		IMAGE_SCN_ALIGN_16BYTES | IMAGE_SCN_MEM_EXECUTE |
 		IMAGE_SCN_MEM_READ;
 	fwrite(&t_sec, sizeof(t_sec), 1, f);
 
 	/*
-	 * Write our dummy relocation and reloc section.
+	 * Add some padding to align the ELF as needed
 	 */
-	memset(&r_sec, 0, sizeof(r_sec));
-	strcpy((char *)r_sec.name, ".reloc");
-	r_sec.virtual_sz = sizeof(c_rel);
-	r_sec.virtual_address = ftell(f) + sizeof(r_sec);
-	r_sec.raw_data_sz = r_sec.virtual_sz;
-	r_sec.raw_data = r_sec.virtual_address;
-	r_sec.characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA |
-		IMAGE_SCN_ALIGN_1BYTES | IMAGE_SCN_MEM_DISCARDABLE |
-		IMAGE_SCN_MEM_READ;
-	fwrite(&r_sec, sizeof(r_sec), 1, f);
-
-	memset(&c_rel, 0, sizeof(c_rel));
-	c_rel.virtual_address = ftell(f) + sizeof(c_rel);
-	c_rel.symtab_index = 10;
-	fwrite(&c_rel, sizeof(c_rel), 1, f);
-	fwrite(&dummy, sizeof(dummy), 1, f);
+	if (ftell(f) > t_sec.virtual_address) {
+		// A fseek that rewind would be a bug hard to track
+		fprintf(stderr, "PE+ headers are too large.\n");
+		exit(EXIT_FAILURE);
+	}
 
+	fseek(f, t_sec.virtual_address, SEEK_SET);
 }
 
 static void usage(char *progname)
@@ -173,17 +157,16 @@
 
 int main(int argc, char **argv)
 {
-	struct stat st;
 	Elf32_Ehdr e32_hdr;
 	Elf64_Ehdr e64_hdr;
 	__uint32_t entry;
 	__uint8_t class;
-	__uint64_t shoff;
-	__uint16_t shnum, shentsize, shstrndx;
+	__uint64_t phoff = 0;
+	__uint16_t phnum = 0, phentsize = 0;
 	unsigned char *id;
 	FILE *f_in, *f_out;
 	void *buf;
-	size_t datasz, rv;
+	size_t datasz, memsz, rv;
 
 	if (argc < 3) {
 		usage(argv[0]);
@@ -196,11 +179,6 @@
 		exit(EXIT_FAILURE);
 	}
 
-	if (stat(argv[1], &st) != 0) {
-		perror("stat");
-		exit(EXIT_FAILURE);
-	}
-
 	f_out = fopen(argv[2], "w");
 	if (!f_out) {
 		perror("fopen");
@@ -210,15 +188,14 @@
 	/*
 	 * Parse the ELF header and find the entry point.
 	 */
- 	fread((void *)&e32_hdr, sizeof(e32_hdr), 1, f_in);
+	fread((void *)&e32_hdr, sizeof(e32_hdr), 1, f_in);
 	if (e32_hdr.e_ident[EI_CLASS] == ELFCLASS32) {
 		id = e32_hdr.e_ident;
 		class = ELFCLASS32;
 		entry = e32_hdr.e_entry;
-		shoff = e32_hdr.e_shoff;
-		shnum = e32_hdr.e_shnum;
-		shstrndx = e32_hdr.e_shstrndx;
-		shentsize = e32_hdr.e_shentsize;
+		phoff = e32_hdr.e_phoff;
+		phnum = e32_hdr.e_phnum;
+		phentsize = e32_hdr.e_phentsize;
 	}
 	else if (e32_hdr.e_ident[EI_CLASS] == ELFCLASS64) {
 		/* read the header again for x86_64 
@@ -229,15 +206,14 @@
 		fread((void *)&e64_hdr, sizeof(e64_hdr), 1, f_in);
 		id = e64_hdr.e_ident;
 		entry = e64_hdr.e_entry;
-		shoff = e64_hdr.e_shoff;
-		shnum = e64_hdr.e_shnum;
-		shstrndx = e64_hdr.e_shstrndx;
-		shentsize = e64_hdr.e_shentsize;
+		phoff = e64_hdr.e_phoff;
+		phnum = e64_hdr.e_phnum;
+		phentsize = e64_hdr.e_phentsize;
 	} else {
 		fprintf(stderr, "Unsupported architecture\n");
 		exit(EXIT_FAILURE);
 	}
-		
+
 	if (id[EI_MAG0] != ELFMAG0 ||
 	    id[EI_MAG1] != ELFMAG1 ||
 	    id[EI_MAG2] != ELFMAG2 ||
@@ -246,98 +222,47 @@
 		exit(EXIT_FAILURE);
 	}
 
-	if (!shoff || !shnum || (shstrndx == SHN_UNDEF)) {
-		fprintf(stderr, "Cannot find section table\n");
+	if (!phoff || !phnum) {
+		fprintf(stderr, "Cannot find segment table\n");
 		exit(EXIT_FAILURE);
 	}
 
 	/*
-	 * Find the beginning of the .bss section. Everything preceding
-	 * it is copied verbatim to the output file.
+	 * Find the LOAD program header. Everything in this segment
+	 * is copied verbatim to the output file.
+	 * Although there may be several LOAD program headers, only
+	 * one is currently copied.
 	 */
 	if (e32_hdr.e_ident[EI_CLASS] == ELFCLASS32) {
-		const char *shstrtab, *name;
-		Elf32_Shdr shdr;
+		Elf32_Phdr phdr;
 		int i;
-		void *strtab;
-
-		fseek(f_in, shoff, SEEK_SET);
-
-		/* First find the strtab section */
-		fseek(f_in, shstrndx * shentsize, SEEK_CUR);
-		fread(&shdr, sizeof(shdr), 1, f_in);
-
-		strtab = malloc(shdr.sh_size);
-		if (!strtab) {
-			fprintf(stderr, "Failed to malloc strtab\n");
-			exit(EXIT_FAILURE);
-		}
 
-		fseek(f_in, shdr.sh_offset, SEEK_SET);
-		fread(strtab, shdr.sh_size, 1, f_in);
+		/* Find the first LOAD program header */
+		for (i = 0; i < phnum; i++) {
+			fseek(f_in, phoff + i * phentsize, SEEK_SET);
+			fread(&phdr, sizeof(phdr), 1, f_in);
 
-		/* Now search for the .bss section */
-		fseek(f_in, shoff, SEEK_SET);
-		for (i = 0; i < shnum; i++) {
-			rv = fread(&shdr, sizeof(shdr), 1, f_in);
-			if (!rv) {
-				fprintf(stderr, "Failed to read section table\n");
-				exit(EXIT_FAILURE);
-			}
-
-			name = strtab + shdr.sh_name;
-			if (!strcmp(name, ".bss"))
+			if (phdr.p_type == PT_LOAD)
 				break;
 		}
 
-		if (i == shnum) {
-			fprintf(stderr, "Failed to find .bss section\n");
-			exit(EXIT_FAILURE);
-		}
-
-		datasz = shdr.sh_offset;
-	}
-	else if (e32_hdr.e_ident[EI_CLASS] == ELFCLASS64) {
-		const char *shstrtab, *name;
-		Elf64_Shdr shdr;
+		datasz = phdr.p_filesz;
+		memsz = phdr.p_memsz;
+	} else if (e32_hdr.e_ident[EI_CLASS] == ELFCLASS64) {
+		Elf64_Phdr phdr;
 		int i;
-		void *strtab;
 
-		fseek(f_in, shoff, SEEK_SET);
+		/* Find the first LOAD program header */
+		for (i = 0; i < phnum; i++) {
+			fseek(f_in, phoff + i * phentsize, SEEK_SET);
+			fread(&phdr, sizeof(phdr), 1, f_in);
 
-		/* First find the strtab section */
-		fseek(f_in, shstrndx * shentsize, SEEK_CUR);
-		fread(&shdr, sizeof(shdr), 1, f_in);
-
-		strtab = malloc(shdr.sh_size);
-		if (!strtab) {
-			fprintf(stderr, "Failed to malloc strtab\n");
-			exit(EXIT_FAILURE);
-		}
-
-		fseek(f_in, shdr.sh_offset, SEEK_SET);
-		fread(strtab, shdr.sh_size, 1, f_in);
-
-		/* Now search for the .bss section */
-		fseek(f_in, shoff, SEEK_SET);
-		for (i = 0; i < shnum; i++) {
-			rv = fread(&shdr, sizeof(shdr), 1, f_in);
-			if (!rv) {
-				fprintf(stderr, "Failed to read section table\n");
-				exit(EXIT_FAILURE);
-			}
-
-			name = strtab + shdr.sh_name;
-			if (!strcmp(name, ".bss"))
+			if (phdr.p_type == PT_LOAD)
 				break;
 		}
 
-		if (i == shnum) {
-			fprintf(stderr, "Failed to find .bss section\n");
-			exit(EXIT_FAILURE);
-		}
-
-		datasz = shdr.sh_offset;
+		datasz = phdr.p_filesz;
+		memsz = phdr.p_memsz;
 	}
 
 	buf = malloc(datasz);
@@ -346,7 +271,7 @@
 		exit(EXIT_FAILURE);
 	}
 
-	write_header(f_out, entry, datasz, st.st_size, class);
+	write_header(f_out, entry, datasz, memsz, class);
 
 	/* Write out the entire ELF shared object */
 	rewind(f_in);
@@ -357,5 +282,8 @@
 	}
 
 	fwrite(buf, datasz, rv, f_out);
+	free(buf);
+	fclose(f_out);
+	fclose(f_in);
 	return 0;
 }
diff -Naur a/efi/wrapper.h b/efi/wrapper.h
--- a/efi/wrapper.h	2013-10-13 19:59:03.000000000 +0200
+++ b/efi/wrapper.h	2013-12-28 03:44:14.948713409 +0100
@@ -102,12 +102,14 @@
 	__uint32_t heap_commit_sz;
 	__uint32_t loader_flags;
 	__uint32_t rva_and_sizes_nr;
-	__uint64_t export_table;
-	__uint64_t import_table;
-	__uint64_t resource_table;
-	__uint64_t exception_table;
-	__uint64_t certification_table;
-	__uint64_t base_relocation_table;
+	struct {
+		__uint64_t export_table;
+		__uint64_t import_table;
+		__uint64_t resource_table;
+		__uint64_t exception_table;
+		__uint64_t certification_table;
+		__uint64_t base_relocation_table;
+	} data_directory;
 } __packed;
 
 /* Extra header for PE32+ format 
@@ -136,12 +138,14 @@
 	__uint64_t heap_commit_sz;
 	__uint32_t loader_flags;
 	__uint32_t rva_and_sizes_nr;
-	__uint64_t export_table;
-	__uint64_t import_table;
-	__uint64_t resource_table;
-	__uint64_t exception_table;
-	__uint64_t certification_table;
-	__uint64_t base_relocation_table;
+	struct {
+		__uint64_t export_table;
+		__uint64_t import_table;
+		__uint64_t resource_table;
+		__uint64_t exception_table;
+		__uint64_t certification_table;
+		__uint64_t base_relocation_table;
+	} data_directory;
 } __packed;
 
 struct section {
diff -Naur a/efi/x86_64/syslinux.ld b/efi/x86_64/syslinux.ld
--- a/efi/x86_64/syslinux.ld	2013-10-13 19:59:03.000000000 +0200
+++ b/efi/x86_64/syslinux.ld	2013-12-28 03:44:14.950713446 +0100
@@ -136,7 +136,7 @@
 		*(.strtab)
 	}
 
-	.bss : {
+	.bss (NOLOAD) : {
 		/* the EFI loader doesn't seem to like a .bss section,
 		   so we stick it all into .data: */
 		__bss_start = .;
@@ -153,7 +153,7 @@
 	__bss_dwords = (__bss_len + 3) >> 2;
 
 	. = ALIGN(128);
-	
+
 	/* Very large objects which don't need to be zeroed */
 
 	.hugebss : {
