--- a/configure.ac	2015-05-11 12:23:06.000000000 +0200
+++ b/configure.ac	2015-05-14 13:39:00.866630353 +0200
@@ -26,7 +26,7 @@
 # (git tag -s pinentry-n.m.k) and run "./autogen.sh --force".  Please
 # bump the version number immediately after the release, do another
 # commit, and a push so that the git magic is able to work.
-m4_define(mym4_version, [0.9.2])
+m4_define(mym4_version, [0.9.3])
 
 # Below is m4 magic to extract and compute the git revision number,
 # the decimalized short revision number, a beta version string and a
@@ -274,28 +274,34 @@
 
 
 dnl
-dnl Check for GTK+-2 pinentry program.
+dnl Check for GTK+-2 / GNOME3 pinentry programs.
 dnl
 AC_ARG_ENABLE(pinentry-gtk2,
             AC_HELP_STRING([--enable-pinentry-gtk2], [build GTK+-2 pinentry]),
             pinentry_gtk_2=$enableval, pinentry_gtk_2=maybe)
 
+AC_ARG_ENABLE(pinentry-gnome3,
+            AC_HELP_STRING([--enable-pinentry-gnome3], [build GNOME 3 pinentry]),
+            pinentry_gnome_3=$enableval, pinentry_gnome_3=maybe)
+
 dnl check for pkg-config
-if test "$pinentry_gtk_2" != "no"; then
+if test "$pinentry_gtk_2" != "no" -o "$pinentry_gnome_3" != "no"; then
         AC_PATH_PROG(PKG_CONFIG, pkg-config, no)
 	if test x"${PKG_CONFIG}" = xno ; then
 		pinentry_gtk_2=no
+		pinentry_gnome_3=no
 	fi
 fi
 
 dnl check if the module gtk+-2.0 exists
-if test "$pinentry_gtk_2" != "no"; then
+if test "$pinentry_gtk_2" != "no" -o "$pinentry_gnome_3" != "no"; then
 	AC_MSG_CHECKING([for gtk+-2])
 	"${PKG_CONFIG}" --exists gtk+-2.0
 	if test $? -ne 0 ; then
 		AC_MSG_RESULT([no])
 		AC_MSG_WARN([pkg-config could not find the module gtk+-2.0])
 		pinentry_gtk_2=no
+		pinentry_gnome_3=no
 	else
 		AC_MSG_RESULT([yes])
 		AC_MSG_CHECKING([gtk+-2 version >= 2.4.0])
@@ -305,17 +311,45 @@
 		if test $? -ne 0 ; then
 			AC_MSG_WARN([building GTK+-2 pinentry disabled])
 			pinentry_gtk_2=no
+			pinentry_gnome_3=no
 		else
 			GTK2CFLAGS=`"${PKG_CONFIG}" --cflags gtk+-2.0`
 			GTK2LIBS=`"${PKG_CONFIG}" --libs gtk+-2.0`
 			AC_SUBST(GTK2CFLAGS)
 			AC_SUBST(GTK2LIBS)
-			pinentry_gtk_2=yes
+			if test "$pinentry_gtk_2" != "no"
+			then
+			  pinentry_gtk_2=yes
+			fi
+			if test "$pinentry_gnome_3" != "no"
+			then
+			  pinentry_gnome_3=yes
+			fi
 		fi
 	fi
 fi
 AM_CONDITIONAL(BUILD_PINENTRY_GTK_2, test "$pinentry_gtk_2" = "yes")
 
+if test "$pinentry_gnome_3" != "no"; then
+	AC_MSG_CHECKING([for gcr])
+	"${PKG_CONFIG}" --exists gcr-3,gcr-base-3
+	if test $? -ne 0 ; then
+		AC_MSG_RESULT([no])
+		AC_MSG_WARN([pkg-config could not find the module gcr-3,gcr-base-3])
+		pinentry_gnome_3=no
+	else
+		AC_MSG_RESULT([yes])
+		GNOME3CFLAGS=`"${PKG_CONFIG}" --cflags gcr-3,gcr-base-3`
+		GNOME3LIBS=`"${PKG_CONFIG}" --libs gcr-3,gcr-base-3`
+		AC_SUBST(GNOME3CFLAGS)
+		AC_SUBST(GNOME3LIBS)
+		AC_DEFINE(GCR_API_SUBJECT_TO_CHANGE, 1, [Nod nod])
+		pinentry_gnome_3=yes
+	fi
+fi
+
+AM_CONDITIONAL(BUILD_PINENTRY_GNOME_3, test "$pinentry_gnome_3" = "yes")
+
 dnl
 dnl Check for libsecret.
 dnl
@@ -450,16 +484,20 @@
   if test "$pinentry_qt4" = "yes"; then
     PINENTRY_DEFAULT=pinentry-qt4
   else
-    if test "$pinentry_curses" = "yes"; then
-      PINENTRY_DEFAULT=pinentry-curses
+    if test "$pinentry_gnome_3" = "yes"; then
+      PINENTRY_DEFAULT=pinentry-gnome3
     else
-      if test "$pinentry_tty" = "yes"; then
-        PINENTRY_DEFAULT=pinentry-tty
+      if test "$pinentry_curses" = "yes"; then
+        PINENTRY_DEFAULT=pinentry-curses
       else
-        if test "$pinentry_w32" = "yes"; then
-          PINENTRY_DEFAULT=pinentry-w32
+        if test "$pinentry_tty" = "yes"; then
+          PINENTRY_DEFAULT=pinentry-tty
         else
-          AC_MSG_ERROR([[No pinentry enabled.]])
+          if test "$pinentry_w32" = "yes"; then
+            PINENTRY_DEFAULT=pinentry-w32
+          else
+            AC_MSG_ERROR([[No pinentry enabled.]])
+          fi
         fi
       fi
     fi
@@ -475,6 +513,7 @@
 curses/Makefile
 tty/Makefile
 gtk+-2/Makefile
+gnome3/Makefile
 qt4/Makefile
 w32/Makefile
 doc/Makefile
@@ -493,6 +532,7 @@
 	Curses Pinentry ..: $pinentry_curses
 	TTY Pinentry .....: $pinentry_tty
 	GTK+-2 Pinentry ..: $pinentry_gtk_2
+	GNOME 3 Pinentry .: $pinentry_gnome_3
 	Qt4 Pinentry .....: $pinentry_qt4 $pinentry_qt4_clip_msg
 	W32 Pinentry .....: $pinentry_w32
 
--- a/curses/Makefile.am	2015-05-11 12:23:06.000000000 +0200
+++ b/curses/Makefile.am	2015-05-14 13:39:00.870630431 +0200
@@ -22,9 +22,8 @@
 bin_PROGRAMS = pinentry-curses
 
 AM_CPPFLAGS = $(COMMON_CFLAGS) $(NCURSES_INCLUDE) -I$(top_srcdir)/pinentry
-LDADD = $(COMMON_LIBS) \
-	../pinentry/libpinentry.a ../pinentry/libpinentry-curses.a \
+LDADD = ../pinentry/libpinentry.a ../pinentry/libpinentry-curses.a \
 	../assuan/libassuan.a ../secmem/libsecmem.a \
-	$(LIBCAP) $(LIBCURSES) $(LIBICONV)
+	$(COMMON_LIBS) $(LIBCAP) $(LIBCURSES) $(LIBICONV)
 
 pinentry_curses_SOURCES = pinentry-curses.c
--- a/doc/pinentry.texi	2015-05-11 12:23:06.000000000 +0200
+++ b/doc/pinentry.texi	2015-05-14 13:39:00.867630373 +0200
@@ -5,7 +5,7 @@
 @include version.texi
 
 @macro copyrightnotice
-Copyright @copyright{} 2002, 2005 g10 Code GmbH
+Copyright @copyright{} 2002, 2005, 2015 g10 Code GmbH
 @end macro
 @macro permissionnotice
 Permission is granted to copy, distribute and/or modify this document
@@ -119,6 +119,7 @@
 Developer information
 
 * Protocol::            The Assuan protocol description.
+* Implementation Details:: For those extending or writing a new pinentry.
 
 Miscellaneous
 
@@ -465,6 +466,182 @@
 
 @end table
 
+@node Implementation Details
+@chapter Implementation Details
+
+The pinentry source code can be divided into three categories.  There
+is a backend module, which lives in @code{pinentry/}, there are
+utility functions, e.g., in @code{secmem/}, and there are various
+frontends.
+
+All of the low-level logic lives in the backend.  This frees the
+frontends from having to implement, e.g., the Assuan protocol.  When
+the backend receives an option, it updates the state in a
+@code{pinentry_t} struct.  The frontend is called when the client
+either calls @code{GETPIN}, @code{CONFIRM} or @code{MESSAGE}.  In
+these cases, the backend invokes the @code{pinentry_cmd_handler},
+which is passed the @code{pinentry_t} struct.
+
+When the callback is invoked, the frontend should create a window
+based on the state in the @code{pinentry_t} struct.  For instance, the
+title to use for the dialog's window (if any) is stored in the
+@code{title} field.  If the is @code{NULL}, the frontend should choose
+a reasonable default value.  (Default is not always provided, because
+different tool kits and environments have different reasonable
+defaults.)
+
+The widget needs to support a number of different interactions with
+the user.  Each of them is described below.
+
+@table @gnupgtabopt
+@item Passphrase Confirmation
+
+When creating a new key, the passphrase should be entered twice.  The
+client (typically GPG Agent) indicates this to the @pinentry{} by
+invoking @code{SETREPEAT}.  In this case, the backend sets the
+@code{repeat_passphrase} field to a copy of the passed string.  The
+value of this field should be used to label a second text input.
+
+It is the frontend's responsibility to check that the passwords match.
+If they don't match, the frontend should display an error message and
+continue to prompt the user.
+
+If the passwords do match, then, when the user presses the okay
+button, the @code{repeat_okay} field should be set to @code{1} (this
+causes the backend to emit the @code{S PIN_REPEATED} status message).
+
+@item Message Box
+
+Sometimes GPG Agent needs to display a message.  In this case, the
+@code{pin} variable is @code{NULL}.
+
+At the Assuan level, this mode is selected by using either the
+@code{MESSAGE} or the @code{CONFIRM} command instead of the
+@code{GETPIN} command.  The @code{MESSAGE} command never shows the
+cancel or an other button.  The same holds for @code{CONFIRM} if it
+was passed the ``--one-button'' argument.  If @code{CONFIRM} was not
+passed this argument, the dialog for @code{CONFIRM} should show both
+the @code{ok} and the @code{cancel} buttons and optionally the
+@code{notok} button.  The frontend can determine whether the dialog is
+a one-button dialog by inspecting the @code{one_button} variable.
+
+@item Passphrase Entry
+
+If neither of the above cases holds, then GPG Agent is simply
+requesting the passphrase.  In this case, the @code{ok} and
+@code{cancel} buttons should be displayed.
+
+@end table
+
+The layout of the three variants is quite similar.  Here are the
+relevant elements that describe the layout:
+
+@table @gnupgtabopt
+@item @code{title}
+The window's title.
+
+@item @code{description}
+The reason for the dialog.  When requesting a passphrase, this
+describes the key.  When showing a message box, this is the message to
+show.
+
+@item @code{error}
+If GPG Agent determines that the passphrase was incorrect, it will
+call @code{GETPIN} again (up to a configurable number of times) to
+again prompt the user.  In this case, this variable contains a
+description of the error message.  This text should typically be
+highlighted in someway.
+
+@item @code{prompt}
+The string to associate with the passphrase entry box.
+
+@item @code{repeat_passphrase}
+The string to associate with the second passphrase entry box.  The
+second passphrase entry box should only be shown if this is not
+@code{NULL}.
+
+@item @code{ok}, @code{default-ok}
+The string to show in the @code{ok} button.
+
+If there are any @code{_} characters, the following character should
+be used as an accelerator.  (A double underscore means a plain
+underscore should be shown.)  If the frontend does not support
+accelerators, then the underscores should be removed manually.
+
+There is a subtle difference between @code{ok} and @code{default-ok}.
+@code{default-ok} means that a stylized OK button should be used.  For
+instance, it could include a check mark.  @code{ok} means that the
+button's meaning is not consistent with such an icon and, as such, no
+icon should be used.  Thus, if the @code{ok} button should have the
+text ``No password required'' then @code{ok} should be used because a
+check mark icon doesn't make sense.
+
+If this variable is @code{NULL}, the frontend should choose a
+reasonable default.
+
+If both variables are set, the @code{ok} variant takes precedence.
+
+@item @code{cancel}, @code{default-cancel}
+Like the @code{ok} and @code{default-ok} buttons except these strings
+are used for the cancel button.
+
+This button should not be shown if @code{one_button} is set.
+
+@code{default-notok}
+Like the @code{default-ok} button except this string is used for the
+other button.
+
+This button should only be displayed when showing a message box.  If
+these variables are @code{NULL} or @code{one_button} is set, this
+button should not be displayed.
+
+@item @code{quality_bar}
+If this is set, a widget should be used to show the password's
+quality.  The value of this field is a label for the widget.
+
+Note: to update the password quality, whenever the password changes,
+call the @code{pinentry_inq_quality} function and then update the
+password quality widget correspondingly.
+
+@item @code{quality_bar_tt}
+A tooltip for the quality bar.
+
+@item @code{default_pwmngr}
+If @code{may_cache_password} and @code{keyinfo} are set and the user
+consents, then the @pinentry{} may cache the password with an external
+manager.  Note: getting the user's consent is essential, because
+password managers often provide a different level of security.  If the
+above condition is true and @code{tried_password_cache} is false, then
+a check box with the specified string should be displayed.  The check
+box must default to off.
+
+@end table
+
+When the handler is done, it should store the passphrase in
+@code{pin}, if appropriate.  This variable is allocated in secure
+memory.  Use @code{pinentry_setbufferlen} to size the buffer.
+
+The actual return code is dependent on whether the dialog is in
+message mode or in passphrase mode.
+
+If the dialog is in message mode and the user pressed ok, return 1.
+Otherwise, return 0.  If an error occured, indicate this by setting it
+in @code{specific_err} or setting @code{locale_err} to @code{1} (for
+locale specific errors).  If the dialog was canceled, then the handler
+should set the @code{canceled} variable to @code{1}.  If the not ok
+button was pressed, don't do anything else.
+
+If the dialog is in passphrase mode return @code{1} if the user
+entered a password and pressed ok.  If an error occured, return
+@code{-1} and set @code{specific_err} or @code{locale_err}, as above.
+If the user canceled the dialog box, return @code{-1}.
+
+If the window was closed, then the handler should set the
+@code{close_button} variable and otherwise act as if the cancel button
+was pressed.
+
+
+
 @c ---------------------------------------------------------------------
 @c Legal Blurbs
 @c ---------------------------------------------------------------------
--- a/gnome3/Makefile.am	1970-01-01 01:00:00.000000000 +0100
+++ b/gnome3/Makefile.am	2015-05-14 13:39:00.871630451 +0200
@@ -0,0 +1,38 @@
+# Makefile.am - PIN entry GTK+ frontend.
+# Copyright (C) 2002, 2015 g10 Code GmbH
+#
+# This file is part of PINENTRY.
+#
+# PINENTRY is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# PINENTRY is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+
+## Process this file with automake to produce Makefile.in
+
+bin_PROGRAMS = pinentry-gnome3
+
+if FALLBACK_CURSES
+ncurses_include = $(NCURSES_INCLUDE)
+libcurses = ../pinentry/libpinentry-curses.a $(LIBCURSES) $(LIBICONV)
+else
+ncurses_include =
+libcurses =
+endif
+
+AM_CPPFLAGS = $(COMMON_CFLAGS) $(GNOME3CFLAGS) \
+	$(ncurses_include) -I$(top_srcdir)/assuan \
+	-I$(top_srcdir)/secmem -I$(top_srcdir)/pinentry
+LDADD = ../pinentry/libpinentry.a ../assuan/libassuan.a ../secmem/libsecmem.a \
+	$(COMMON_LIBS) $(LIBCAP) $(GNOME3LIBS) $(libcurses)
+
+pinentry_gnome3_SOURCES = pinentry-gnome3.c
--- a/gnome3/pinentry-gnome3.c	1970-01-01 01:00:00.000000000 +0100
+++ b/gnome3/pinentry-gnome3.c	2015-05-14 13:39:00.866630353 +0200
@@ -0,0 +1,271 @@
+/* pinentry-gnome3.c
+   Copyright (C) 2015 g10 Code GmbH
+
+   pinentry-gnome-3 is a pinentry application for GNOME 3.  It tries
+   to follow the Gnome Human Interface Guide as close as possible.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <gtk/gtk.h>
+#include <gcr/gcr-base.h>
+
+#include <string.h>
+
+#include "assuan.h"
+
+#include "memory.h"
+
+#include "pinentry.h"
+
+#ifdef FALLBACK_CURSES
+#include "pinentry-curses.h"
+#endif
+
+
+#define PGMNAME "pinentry-gnome3"
+
+#ifndef VERSION
+#  define VERSION
+#endif
+
+static gchar *
+pinentry_utf8_validate (gchar *text)
+{
+  gchar *result;
+
+  if (!text)
+    return NULL;
+
+  if (g_utf8_validate (text, -1, NULL))
+    return g_strdup (text);
+
+  /* Failure: Assume that it was encoded in the current locale and
+     convert it to utf-8.  */
+  result = g_locale_to_utf8 (text, -1, NULL, NULL, NULL);
+  if (!result)
+    {
+      gchar *p;
+
+      result = p = g_strdup (text);
+      while (!g_utf8_validate (p, -1, (const gchar **) &p))
+	*p = '?';
+    }
+  return result;
+}
+
+static GcrPrompt *
+create_prompt (pinentry_t pe, int confirm)
+{
+  GcrPrompt *prompt;
+  GError *error = NULL;
+  char *msg;
+
+  /* Create the prompt.  */
+  prompt = GCR_PROMPT (gcr_system_prompt_open (-1, NULL, &error));
+  if (! prompt)
+    {
+      g_warning ("couldn't create prompt for gnupg passphrase: %s",
+		 error->message);
+      g_error_free (error);
+      return NULL;
+    }
+
+  /* Set the messages for the various buttons, etc.  */
+  if (pe->title)
+    {
+      msg = pinentry_utf8_validate (pe->title);
+      gcr_prompt_set_title (prompt, msg);
+      g_free (msg);
+    }
+
+  if (pe->description)
+    {
+      msg = pinentry_utf8_validate (pe->description);
+      gcr_prompt_set_description (prompt, msg);
+      g_free (msg);
+    }
+
+  /* An error occured during the last prompt.  */
+  if (pe->error)
+    {
+      msg = pinentry_utf8_validate (pe->error);
+      gcr_prompt_set_warning (prompt, msg);
+      g_free (msg);
+    }
+
+  if (! pe->prompt && confirm)
+    gcr_prompt_set_message (prompt, "Message");
+  else if (! pe->prompt && ! confirm)
+    gcr_prompt_set_message (prompt, "Enter Passphrase");
+  else
+    {
+      msg = pinentry_utf8_validate (pe->prompt);
+      gcr_prompt_set_message (prompt, msg);
+      g_free (msg);
+    }
+
+  if (! confirm)
+    gcr_prompt_set_password_new (prompt, !!pe->repeat_passphrase);
+
+  if (pe->ok || pe->default_ok)
+    {
+      msg = pinentry_utf8_validate (pe->ok ?: pe->default_ok);
+      gcr_prompt_set_continue_label (prompt, msg);
+      g_free (msg);
+    }
+  /* XXX: Disable this button if pe->one_button is set.  */
+  if (pe->cancel || pe->default_cancel)
+    {
+      msg = pinentry_utf8_validate (pe->cancel ?: pe->default_cancel);
+      gcr_prompt_set_cancel_label (prompt, msg);
+      g_free (msg);
+    }
+
+  if (confirm && pe->notok)
+    {
+      /* XXX: Add support for the third option.  */
+    }
+
+  /* XXX: gcr expects a string; we have a int.  */
+  // gcr_prompt_set_caller_window (prompt, pe->parent_wid);
+
+  if (! confirm && pe->allow_external_password_cache && pe->keyinfo)
+    {
+      if (pe->default_pwmngr)
+	{
+	  msg = pinentry_utf8_validate (pe->default_pwmngr);
+	  gcr_prompt_set_choice_label (prompt, msg);
+	  g_free (msg);
+	}
+      else
+	gcr_prompt_set_choice_label
+	  (prompt, "Automatically unlock this key, whenever I'm logged in");
+    }
+
+  return prompt;
+}
+
+static int
+gnome3_cmd_handler (pinentry_t pe)
+{
+  GcrPrompt *prompt = NULL;
+  GError *error = NULL;
+  int ret = -1;
+
+  if (pe->pin)
+    /* Passphrase mode.  */
+    {
+      const char *password;
+
+      prompt = create_prompt (pe, 0);
+      if (! prompt)
+	/* Something went wrong.  */
+	{
+	  pe->canceled = 1;
+	  return -1;
+	}
+
+      /* "The returned password is valid until the next time a method
+	 is called to display another prompt."  */
+      password = gcr_prompt_password_run (prompt, NULL, &error);
+      if (error)
+	/* Error.  */
+	{
+	  pe->specific_err = ASSUAN_General_Error;
+	  g_error_free (error);
+	  ret = -1;
+	}
+      else if (! password && ! error)
+	/* User cancelled the operation.  */
+	ret = -1;
+      else
+	{
+	  pinentry_setbufferlen (pe, strlen (password) + 1);
+	  if (pe->pin)
+	    strcpy (pe->pin, password);
+
+	  if (pe->repeat_passphrase)
+	    pe->repeat_okay = 1;
+
+	  ret = 1;
+	}
+    }
+  else
+    /* Message box mode.  */
+    {
+      GcrPromptReply reply;
+
+      prompt = create_prompt (pe, 1);
+      if (! prompt)
+	/* Something went wrong.  */
+	{
+	  pe->canceled = 1;
+	  return -1;
+	}
+
+      /* XXX: We don't support a third button!  */
+
+      reply = gcr_prompt_confirm_run (prompt, NULL, &error);
+      if (error)
+	{
+	  pe->specific_err = ASSUAN_General_Error;
+	  ret = 0;
+	}
+      else if (reply == GCR_PROMPT_REPLY_CONTINUE
+	       /* XXX: Hack since gcr doesn't yet support one button
+		  message boxes treat cancel the same as okay.  */
+	       || pe->one_button)
+	/* Confirmation.  */
+	ret = 1;
+      else
+	/* GCR_PROMPT_REPLY_CANCEL */
+	{
+	  pe->canceled = 1;
+	  ret = 0;
+	}
+    }
+
+  if (prompt)
+    g_clear_object (&prompt);
+  return ret;
+}
+
+pinentry_cmd_handler_t pinentry_cmd_handler = gnome3_cmd_handler;
+
+int
+main (int argc, char *argv[])
+{
+  pinentry_init (PGMNAME);
+
+#ifdef FALLBACK_CURSES
+  if (pinentry_have_display (argc, argv))
+    gtk_init (&argc, &argv);
+  else
+    pinentry_cmd_handler = curses_cmd_handler;
+#else
+  gtk_init (&argc, &argv);
+#endif
+
+  pinentry_parse_opts (argc, argv);
+
+  if (pinentry_loop ())
+    return 1;
+
+  return 0;
+}
--- a/gtk+-2/Makefile.am	2015-05-11 12:23:06.000000000 +0200
+++ b/gtk+-2/Makefile.am	2015-05-14 13:39:00.871630451 +0200
@@ -31,9 +31,8 @@
 
 AM_CPPFLAGS = $(COMMON_CFLAGS) $(GTK2CFLAGS) $(ncurses_include) \
 	-I$(top_srcdir)/secmem -I$(top_srcdir)/pinentry
-LDADD = $(COMMON_LIBS) \
-	../pinentry/libpinentry.a ../assuan/libassuan.a ../secmem/libsecmem.a \
-	$(LIBCAP) $(GTK2LIBS) $(libcurses)
+LDADD = ../pinentry/libpinentry.a ../assuan/libassuan.a ../secmem/libsecmem.a \
+	$(COMMON_LIBS) $(LIBCAP) $(GTK2LIBS) $(libcurses)
 
 pinentry_gtk_2_SOURCES = pinentry-gtk-2.c \
 	gtksecentry.c gtksecentry.h gseal-gtk-compat.h
--- a/Makefile.am	2015-03-18 11:42:16.000000000 +0100
+++ b/Makefile.am	2015-05-14 13:39:00.866630353 +0200
@@ -1,5 +1,5 @@
 # Makefile.am
-# Copyright (C) 2002, 2012 g10 Code GmbH
+# Copyright (C) 2002, 2012, 2015 g10 Code GmbH
 #
 # This file is part of PINENTRY.
 #
@@ -46,6 +46,12 @@
 pinentry_gtk_2 =
 endif
 
+if BUILD_PINENTRY_GNOME_3
+pinentry_gnome_3 = gnome3
+else
+pinentry_gnome_3 =
+endif
+
 if BUILD_PINENTRY_QT4
 pinentry_qt4 = qt4
 else
@@ -59,7 +65,8 @@
 endif
 
 SUBDIRS = assuan secmem pinentry ${pinentry_curses} ${pinentry_tty} \
-	  ${pinentry_gtk_2} ${pinentry_qt4} ${pinentry_w32} doc
+	${pinentry_gtk_2} ${pinentry_gnome_3} ${pinentry_qt4} \
+	${pinentry_w32} doc
 
 
 install-exec-local:
--- a/NEWS	2015-05-11 15:28:38.000000000 +0200
+++ b/NEWS	2015-05-14 13:39:00.861630256 +0200
@@ -1,3 +1,7 @@
+Noteworthy changes in version 0.9.3 (unreleased)
+------------------------------------------------
+
+
 Noteworthy changes in version 0.9.2 (2015-05-11)
 ------------------------------------------------
 
--- a/pinentry/pinentry.c	2015-05-11 13:02:34.000000000 +0200
+++ b/pinentry/pinentry.c	2015-05-14 13:39:00.874630509 +0200
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <assert.h>
 #ifndef HAVE_W32CE_SYSTEM
 # include <locale.h>
 #endif
@@ -67,7 +68,7 @@
     NULL,	/* Not-Ok button.  */
     NULL,	/* Cancel button.  */
     NULL,	/* PIN.  */
-    2048,	/* PIN length.  */
+    0,		/* PIN length.  */
     0,          /* pin_from_cache.  */
     0,		/* Display.  */
     0,		/* TTY name.  */
@@ -354,13 +355,23 @@
 pinentry_setbufferlen (pinentry_t pin, int len)
 {
   char *newp;
-  if (len < pinentry.pin_len)
+
+  if (pin->pin_len)
+    assert (pin->pin);
+  else
+    assert (!pin->pin);
+
+  if (len < 2048)
+    len = 2048;
+
+  if (len <= pin->pin_len)
     return NULL;
-  newp = secmem_realloc (pin->pin, 2 * pin->pin_len);
+
+  newp = secmem_realloc (pin->pin, len);
   if (newp)
     {
       pin->pin = newp;
-      pin->pin_len *= 2;
+      pin->pin_len = len;
     }
   else
     {
@@ -371,6 +382,50 @@
   return newp;
 }
 
+static void
+pinentry_setbuffer_clear (pinentry_t pin)
+{
+  if (! pin->pin)
+    {
+      assert (pin->pin_len == 0);
+      return;
+    }
+
+  assert (pin->pin_len > 0);
+
+  secmem_free (pin->pin);
+  pin->pin = NULL;
+  pin->pin_len = 0;
+}
+
+static void
+pinentry_setbuffer_init (pinentry_t pin)
+{
+  pinentry_setbuffer_clear (pin);
+  pinentry_setbufferlen (pin, 0);
+}
+
+/* passphrase better be alloced with secmem_alloc.  */
+void
+pinentry_setbuffer_use (pinentry_t pin, char *passphrase, int len)
+{
+  if (! passphrase)
+    {
+      assert (len == 0);
+      pinentry_setbuffer_clear (pin);
+
+      return;
+    }
+
+  if (passphrase && len == 0)
+    len = strlen (passphrase) + 1;
+
+  if (pin->pin)
+    secmem_free (pin->pin);
+
+  pin->pin = passphrase;
+  pin->pin_len = len;
+}
 
 /* Initialize the secure memory subsystem, drop privileges and return.
    Must be called early. */
@@ -983,7 +1038,7 @@
   int set_prompt = 0;
   int just_read_password_from_cache = 0;
 
-  pinentry.pin = secmem_malloc (pinentry.pin_len);
+  pinentry_setbuffer_init (&pinentry);
   if (!pinentry.pin)
     return ASSUAN_Out_Of_Core;
 
@@ -1065,11 +1120,7 @@
 
   if (result < 0)
     {
-      if (pinentry.pin)
-	{
-	  secmem_free (pinentry.pin);
-	  pinentry.pin = NULL;
-	}
+      pinentry_setbuffer_clear (&pinentry);
       if (pinentry.specific_err)
         return pinentry.specific_err;
       return pinentry.locale_err? ASSUAN_Locale_Problem: ASSUAN_Canceled;
@@ -1080,7 +1131,7 @@
     {
       if (pinentry.repeat_okay)
         assuan_write_status (ctx, "PIN_REPEATED", "");
-      result = assuan_send_data (ctx, pinentry.pin, result);
+      result = assuan_send_data (ctx, pinentry.pin, strlen(pinentry.pin));
       if (!result)
 	result = assuan_send_data (ctx, NULL, 0);
 
@@ -1094,11 +1145,7 @@
 	password_cache_save (pinentry.keyinfo, pinentry.pin);
     }
 
-  if (pinentry.pin)
-    {
-      secmem_free (pinentry.pin);
-      pinentry.pin = NULL;
-    }
+  pinentry_setbuffer_clear (&pinentry);
 
   return result;
 }
@@ -1122,6 +1169,7 @@
   pinentry.locale_err = 0;
   pinentry.specific_err = 0;
   pinentry.canceled = 0;
+  pinentry_setbuffer_clear (&pinentry);
   result = (*pinentry_cmd_handler) (&pinentry);
   if (pinentry.error)
     {
@@ -1132,41 +1180,28 @@
   if (pinentry.close_button)
     assuan_write_status (ctx, "BUTTON_INFO", "close");
 
-  return result ? 0
-                : (pinentry.specific_err? pinentry.specific_err :
-                   pinentry.locale_err? ASSUAN_Locale_Problem
-                                      : (pinentry.one_button
-                                         ? 0
-                                         : (pinentry.canceled
-                                            ? ASSUAN_Canceled
-                                            : ASSUAN_Not_Confirmed)));
+  if (result)
+    return 0;
+
+  if (pinentry.specific_err)
+    return pinentry.specific_err;
+
+  if (pinentry.locale_err)
+    return ASSUAN_Locale_Problem;
+
+  if (pinentry.one_button)
+    return 0;
+
+  if (pinentry.canceled)
+    return ASSUAN_Canceled;
+  return ASSUAN_Not_Confirmed;
 }
 
 
 static int
 cmd_message (ASSUAN_CONTEXT ctx, char *line)
 {
-  int result;
-
-  pinentry.one_button = 1;
-  pinentry.quality_bar = 0;
-  pinentry.close_button = 0;
-  pinentry.locale_err = 0;
-  pinentry.specific_err = 0;
-  result = (*pinentry_cmd_handler) (&pinentry);
-  if (pinentry.error)
-    {
-      free (pinentry.error);
-      pinentry.error = NULL;
-    }
-
-  if (pinentry.close_button)
-    assuan_write_status (ctx, "BUTTON_INFO", "close");
-
-  return result ? 0
-                : (pinentry.specific_err? pinentry.specific_err :
-                   pinentry.locale_err? ASSUAN_Locale_Problem
-                                      : 0);
+  return cmd_confirm (ctx, "--one-button");
 }
 
 /* GETINFO <what>
--- a/pinentry/pinentry.h	2015-05-11 12:40:38.000000000 +0200
+++ b/pinentry/pinentry.h	2015-05-14 13:39:00.874630509 +0200
@@ -39,20 +39,28 @@
 
 struct pinentry
 {
-  /* The window title, or NULL.  */
+  /* The window title, or NULL.  (Assuan: "SETTITLE TITLE".)  */
   char *title;
-  /* The description to display, or NULL.  */
+  /* The description to display, or NULL.  (Assuan: "SETDESC
+     DESC".) */
   char *description;
-  /* The error message to display, or NULL.  */
+  /* The error message to display, or NULL.  (Assuan: "SETERROR
+     MESSAGE".) */
   char *error;
-  /* The prompt to display, or NULL.  */
+  /* The prompt to display, or NULL.  (Assuan: "SETPROMPT
+     prompt".)  */
   char *prompt;
-  /* The OK button text to display, or NULL.  */
+  /* The OK button text to display, or NULL.  (Assuan: "SETOK
+     OK".)  */
   char *ok;
-  /* The Not-OK button text to display, or NULL.  */
+  /* The Not-OK button text to display, or NULL.  This is the text for
+     the alternative option shown by the third button.  (Assuan:
+     "SETNOTOK NOTOK".)  */
   char *notok;
-  /* The Cancel button text to display, or NULL.  */
+  /* The Cancel button text to display, or NULL.  (Assuan: "SETCANCEL
+     CANCEL".)  */
   char *cancel;
+
   /* The buffer to store the secret into.  */
   char *pin;
   /* The length of the buffer.  */
@@ -61,15 +69,19 @@
      the user (0). */
   int pin_from_cache;
 
-  /* The name of the X display to use if X is available and supported.  */
+  /* The name of the X display to use if X is available and supported.
+     (Assuan: "OPTION display DISPLAY".)  */
   char *display;
-  /* The name of the terminal node to open if X not available or supported.  */
+  /* The name of the terminal node to open if X not available or
+     supported.  (Assuan: "OPTION ttyname TTYNAME".)  */
   char *ttyname;
-  /* The type of the terminal.  */
+  /* The type of the terminal.  (Assuan: "OPTION ttytype TTYTYPE".)  */
   char *ttytype;
-  /* The LC_CTYPE value for the terminal.  */
+  /* The LC_CTYPE value for the terminal.  (Assuan: "OPTION lc-ctype
+     LC_CTYPE".)  */
   char *lc_ctype;
-  /* The LC_MESSAGES value for the terminal.  */
+  /* The LC_MESSAGES value for the terminal.  (Assuan: "OPTION
+     lc-messages LC_MESSAGES".)  */
   char *lc_messages;
 
   /* True if debug mode is requested.  */
@@ -83,35 +95,38 @@
   int enhanced;
 #endif
 
-  /* True if caller should grab the keyboard.  */
+  /* True if caller should grab the keyboard.  (Assuan: "OPTION grab"
+     or "OPTION no-grab".)  */
   int grab;
   /* The window ID of the parent window over which the pinentry window
-     should be displayed.  */
+     should be displayed.  (Assuan: "OPTION parent-wid WID".)  */
   int parent_wid;
 
   /* The name of an optional file which will be touched after a curses
-     entry has been displayed.  */
+     entry has been displayed.  (Assuan: "OPTION touch-file
+     FILENAME".)  */
   char *touch_file;
 
-  /* The user should set this to -1 if the user canceled the request,
-     and to the length of the PIN stored in pin otherwise.  */
+  /* The frontend should set this to -1 if the user canceled the
+     request, and to the length of the PIN stored in pin
+     otherwise.  */
   int result;
 
-  /* The user should set this if the NOTOK button was pressed.  */
+  /* The frontend should set this if the NOTOK button was pressed.  */
   int canceled;
 
-  /* The user should set this to true if an error with the local
+  /* The frontend should set this to true if an error with the local
      conversion occured. */
   int locale_err;
 
-  /* The user should set this to an gpg-error so that commands are
-     abale to return specific error codes.  This is an ugly hack due
-     to the fact that pinentry_cmd_handler_t return the length of the
-     passphrase or an negative error code.  */
+  /* The frontend should set this to a gpg-error so that commands are
+     able to return specific error codes.  This is an ugly hack due to
+     the fact that pinentry_cmd_handler_t returns the length of the
+     passphrase or a negative error code.  */
   int specific_err;
 
-  /* The user should set this to true if the window close button has
-     been used.  This flag is used in addition to a regular return
+  /* The frontend should set this to true if the window close button
+     has been used.  This flag is used in addition to a regular return
      value.  */
   int close_button;
 
@@ -122,10 +137,11 @@
 
   /* If true a second prompt for the passphrase is shown and the user
      is expected to enter the same passphrase again.  Pinentry checks
-     that both match.  */
+     that both match.  (Assuan: "SETREPEAT".)  */
   char *repeat_passphrase;
 
-  /* The string to show if a repeated passphrase does not match.  */
+  /* The string to show if a repeated passphrase does not match.
+     (Assuan: "SETREPEATERROR ERROR".)  */
   char *repeat_error_string;
 
   /* Set to true if the passphrase has been entered a second time and
@@ -135,10 +151,12 @@
   /* If this is not NULL, a passphrase quality indicator is shown.
      There will also be an inquiry back to the caller to get an
      indication of the quality for the passphrase entered so far.  The
-     string is used as a label for the quality bar.  */
+     string is used as a label for the quality bar.  (Assuan:
+     "SETQUALITYBAR LABEL".)  */
   char *quality_bar;
 
-  /* The tooltip to be show for the qualitybar.  Malloced or NULL.  */
+  /* The tooltip to be show for the qualitybar.  Malloced or NULL.
+     (Assuan: "SETQUALITYBAR_TT TOOLTIP".)  */
   char *quality_bar_tt;
 
   /* For the curses pinentry, the color of error messages.  */
@@ -151,19 +169,25 @@
   /* Malloced and i18ned default strings or NULL.  These strings may
      include an underscore character to indicate an accelerator key.
      A double underscore represents a plain one.  */
+  /* (Assuan: "OPTION default-ok OK").  */
   char *default_ok;
+  /* (Assuan: "OPTION default-cancel CANCEL").  */
   char *default_cancel;
+  /* (Assuan: "OPTION default-prompt PROMPT").  */
   char *default_prompt;
+  /* (Assuan: "OPTION default-pwmngr
+     SAVE_PASSWORD_WITH_PASSWORD_MANAGER?").  */
   char *default_pwmngr;
 
   /* Whether we are allowed to read the password from an external
-     cache.  */
+     cache.  (Assuan: "OPTION allow-external-password-cache")  */
   int allow_external_password_cache;
 
   /* We only try the cache once.  */
   int tried_password_cache;
 
-  /* A stable identifier for the key.  */
+  /* A stable identifier for the key.  (Assuan: "SETKEYINFO
+     KEYINFO".)  */
   char *keyinfo;
 
   /* Whether we may cache the password (according to the user).  */
@@ -216,6 +240,12 @@
    PIN.  Returns new buffer on success and 0 on failure.  */
 char *pinentry_setbufferlen (pinentry_t pin, int len);
 
+/* Use the buffer at BUFFER for PIN->PIN.  BUFFER must be NULL or
+   allocated using secmem_alloc.  LEN is the size of the buffer.  If
+   it is unknown, but BUFFER is a NUL terminated string, you pass 0 to
+   just use strlen(buffer)+1.  */
+void pinentry_setbuffer_use (pinentry_t pin, char *buffer, int len);
+
 /* Initialize the secure memory subsystem, drop privileges and
    return.  Must be called early.  */
 void pinentry_init (const char *pgmname);
--- a/qt4/Makefile.am	2015-05-11 12:23:06.000000000 +0200
+++ b/qt4/Makefile.am	2015-05-14 13:39:00.871630451 +0200
@@ -38,10 +38,10 @@
 	-I$(top_srcdir) -I$(top_srcdir)/assuan -I$(top_srcdir)/secmem \
 	$(ncurses_include) -I$(top_srcdir)/pinentry
 AM_CXXFLAGS = $(QT4_CORE_CFLAGS) $(QT4_GUI_CFLAGS)
-pinentry_qt4_LDADD = $(COMMON_LIBS) \
-	$(QT4_CORE_LIBS) $(QT4_GUI_LIBS) $(libcurses) \
+pinentry_qt4_LDADD = \
 	../pinentry/libpinentry.a $(top_builddir)/assuan/libassuan.a \
-	$(top_builddir)/secmem/libsecmem.a $(LIBCAP)
+	$(top_builddir)/secmem/libsecmem.a \
+	$(COMMON_LIBS) $(QT4_CORE_LIBS) $(QT4_GUI_LIBS) $(libcurses) $(LIBCAP)
 
 BUILT_SOURCES = \
 	pinentryconfirm.moc qsecurelineedit.moc pinentrydialog.moc
--- a/tty/Makefile.am	2015-05-11 12:23:06.000000000 +0200
+++ b/tty/Makefile.am	2015-05-14 13:39:00.875630528 +0200
@@ -20,9 +20,9 @@
 
 bin_PROGRAMS = pinentry-tty
 
-AM_CPPFLAGS = $(COMMON_CFLAGS) -I$(top_srcdir)/pinentry
-LDADD = $(COMMON_LIBS) ../pinentry/libpinentry.a \
+AM_CPPFLAGS = $(COMMON_CFLAGS) -I$(top_srcdir)/secmem -I$(top_srcdir)/pinentry
+LDADD = ../pinentry/libpinentry.a \
 	../assuan/libassuan.a ../secmem/libsecmem.a \
-	$(LIBCAP) $(LIBICONV)
+	$(COMMON_LIBS) $(LIBCAP) $(LIBICONV)
 
 pinentry_tty_SOURCES = pinentry-tty.c
--- a/tty/pinentry-tty.c	2015-05-11 12:23:06.000000000 +0200
+++ b/tty/pinentry-tty.c	2015-05-14 13:39:00.875630528 +0200
@@ -36,8 +36,10 @@
 #endif /*HAVE_UTIME_H*/
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <ctype.h>
 
 #include "pinentry.h"
+#include "memory.h"
 
 #ifndef HAVE_DOSISH_SYSTEM
 static int timed_out;
@@ -60,30 +62,115 @@
   return 1;
 }
 
-static int
-confirm (pinentry_t pinentry, FILE *ttyfi, FILE *ttyfo)
+#define UNDERLINE_START "\033[4m"
+/* Bold, red.  */
+#define ALERT_START "\033[1;31m"
+#define NORMAL_RESTORE "\033[0m"
+
+static char
+button (char *text, char *default_text, FILE *ttyfo)
 {
-  char buf[32], *ret;
-  pinentry->canceled = 1;
-  fprintf (ttyfo, "%s [y/N]? ", pinentry->ok ? pinentry->ok : "OK");
-  fflush (ttyfo);
-  buf[0] = '\0';
-  ret = fgets (buf, sizeof(buf), ttyfi);
-  if (ret && (buf[0] == 'y' || buf[0] == 'Y'))
+  char *highlight;
+
+  if (! text)
+    return 0;
+
+  /* Skip any leading white space.  */
+  while (*text == ' ')
+    text ++;
+
+  highlight = text;
+  while ((highlight = strchr (highlight, '_')))
     {
-      pinentry->canceled = 0;
-      return 1;
+      highlight = highlight + 1;
+      if (*highlight == '_')
+	/* Escaped underscore.  */
+	continue;
+      else
+	break;
+    }
+
+  if (! highlight)
+    /* Not accelerator.  Take the first alpha-numeric character.  */
+    {
+      highlight = text;
+      while (*highlight && !isalnum (*highlight))
+	highlight ++;
+    }
+
+  if (! highlight)
+    /* Hmm, no alpha-num characters.  */
+    {
+      if (! default_text)
+	return 0;
+      text = highlight = default_text;
     }
-  return 0;
-}
 
+  fputs ("  ", ttyfo);
+  for (; *text; text ++)
+    {
+      /* Skip accelerator prefix.  */
+      if (*text == '_')
+	continue;
+
+      if (text == highlight)
+	fputs (UNDERLINE_START, ttyfo);
+      fputc (*text, ttyfo);
+      if (text == highlight)
+	fputs (NORMAL_RESTORE, ttyfo);
+    }
+  fputc ('\n', ttyfo);
+
+  return *highlight;
+}
 
 static int
-read_password (pinentry_t pinentry, FILE *ttyfi, FILE *ttyfo)
+confirm (pinentry_t pinentry, FILE *ttyfi, FILE *ttyfo)
 {
-  int count;
-  int done;
-  char *prompt = NULL;
+  char *msg;
+
+  char ok = 0;
+  char notok = 0;
+  char cancel = 0;
+
+  int ret;
+
+  if (pinentry->error)
+    fprintf (ttyfo, "*** %s%s%s ***\n",
+	     ALERT_START, pinentry->error, NORMAL_RESTORE);
+
+  msg = pinentry->description;
+  if (! msg)
+    /* If there is no description, fallback to the title.  */
+    msg = pinentry->title;
+  if (! msg)
+    msg = "Confirm:";
+
+  if (msg)
+    {
+      fputs (msg, ttyfo);
+      fputc ('\n', ttyfo);
+    }
+
+  fflush (ttyfo);
+
+  if (pinentry->default_ok)
+    ok = button (pinentry->default_ok, "OK", ttyfo);
+  else if (pinentry->ok)
+    ok = button (pinentry->ok, "OK", ttyfo);
+  else
+    ok = button ("OK", NULL, ttyfo);
+
+  if (! pinentry->one_button)
+    {
+      if (pinentry->default_cancel)
+	cancel = button (pinentry->default_cancel, "Cancel", ttyfo);
+      else if (pinentry->cancel)
+	cancel = button (pinentry->cancel, "Cancel", ttyfo);
+
+      if (pinentry->notok)
+	notok = button (pinentry->notok, NULL, ttyfo);
+    }
 
   if (cbreak (fileno (ttyfi)) == -1)
     {
@@ -93,27 +180,110 @@
       return -1;
     }
 
-  prompt = pinentry->prompt;
-  if (! prompt || !*prompt)
-    prompt = "PIN";
-
-  fprintf (ttyfo, "%s\n%s%s ",
-           pinentry->description? pinentry->description:"",
-           prompt,
-	   /* Make sure the prompt ends in a : or a question mark.  */
-	   (prompt[strlen(prompt) - 1] == ':'
-	    || prompt[strlen(prompt) - 1] == '?') ? "" : ":");
-  fflush (ttyfo);
+  if (pinentry->one_button)
+    fprintf (ttyfo, "Press any key to continue.");
+  else
+    {
+      fputc ('[', ttyfo);
+      if (ok)
+	fputc (tolower (ok), ttyfo);
+      if (cancel)
+	fputc (tolower (cancel), ttyfo);
+      if (notok)
+	fputc (tolower (notok), ttyfo);
+      fputs("]? ", ttyfo);
+    }
+
+  while (1)
+    {
+      int input = fgetc (ttyfi);
+      if (input == EOF || input == 0x4)
+	/* End of file or control-d (= end of file).  */
+	{
+	  pinentry->close_button = 1;
+
+	  pinentry->canceled = 1;
+	  ret = 0;
+	  break;
+	}
+
+      if (pinentry->one_button)
+	{
+	  ret = 1;
+	  break;
+	}
+
+      if (cancel && (input == toupper (cancel) || input == tolower (cancel)))
+	{
+	  pinentry->canceled = 1;
+	  ret = 0;
+	  break;
+	}
+      else if (notok && (input == toupper (notok) || input == tolower (notok)))
+	{
+	  ret = 0;
+	  break;
+	}
+      else if (ok && (input == toupper (ok) || input == tolower (ok)))
+	{
+	  ret = 1;
+	  break;
+	}
+    }
+
+  fputc('\n', ttyfo);
+
+  tcsetattr (fileno(ttyfi), TCSANOW, &o_term);
+
+  return ret;
+}
+
+static char *
+read_password (FILE *ttyfi, FILE *ttyfo)
+{
+  int done = 0;
+  int len = 128;
+  int count = 0;
+  char *buffer;
+
+  if (cbreak (fileno (ttyfi)) == -1)
+    {
+      int err = errno;
+      fprintf (stderr, "cbreak failure, exiting\n");
+      errno = err;
+      return NULL;
+    }
 
-  memset (pinentry->pin, 0, pinentry->pin_len);
+  buffer = secmem_malloc (len);
+  if (! buffer)
+    return NULL;
 
-  done = count = 0;
-  while (!done && count < pinentry->pin_len - 1)
+  while (!done)
     {
-      char c = fgetc (ttyfi);
+      int c;
+
+      if (count == len - 1)
+	/* Double the buffer's size.  Note: we check if count is len -
+	   1 and not len so that we always have space for the NUL
+	   character.  */
+	{
+	  char *tmp = secmem_realloc (buffer, 2 * len);
+	  if (! tmp)
+	    {
+	      secmem_free (tmp);
+	      return NULL;
+	    }
+	  buffer = tmp;
+	}
 
+      c = fgetc (ttyfi);
       switch (c)
 	{
+	case 0x4: case EOF:
+	  /* Control-d (i.e., end of file) or a real EOF.  */
+	  done = -1;
+	  break;
+
 	case '\n':
 	  done = 1;
 	  break;
@@ -125,15 +295,102 @@
 	  break;
 
 	default:
-	  pinentry->pin[count ++] = c;
+	  buffer[count ++] = c;
 	  break;
 	}
     }
-  pinentry->pin[count] = '\0';
-  fputc('\n', stdout);
+  buffer[count] = '\0';
 
   tcsetattr (fileno(ttyfi), TCSANOW, &o_term);
-  return strlen (pinentry->pin);
+
+  if (done == -1)
+    {
+      secmem_free (buffer);
+      return NULL;
+    }
+
+  return buffer;
+}
+
+
+static int
+password (pinentry_t pinentry, FILE *ttyfi, FILE *ttyfo)
+{
+  char *msg;
+  int done = 0;
+
+  msg = pinentry->description;
+  if (! msg)
+    msg = pinentry->title;
+  if (! msg)
+    msg = "Enter your passphrase.";
+
+  fprintf (ttyfo, "%s\n ", msg);
+
+  while (! done)
+    {
+      char *passphrase;
+
+      char *prompt = pinentry->prompt;
+      if (! prompt || !*prompt)
+	prompt = "PIN";
+
+      fprintf (ttyfo, "%s%s ",
+	       prompt,
+	       /* Make sure the prompt ends in a : or a question mark.  */
+	       (prompt[strlen(prompt) - 1] == ':'
+		|| prompt[strlen(prompt) - 1] == '?') ? "" : ":");
+      fflush (ttyfo);
+
+      passphrase = read_password (ttyfi, ttyfo);
+      fputc ('\n', ttyfo);
+      if (! passphrase)
+	{
+	  done = -1;
+	  break;
+	}
+
+      if (! pinentry->repeat_passphrase)
+	done = 1;
+      else
+	{
+	  char *passphrase2;
+
+	  prompt = pinentry->repeat_passphrase;
+	  fprintf (ttyfo, "%s%s ",
+		   prompt,
+		   /* Make sure the prompt ends in a : or a question mark.  */
+		   (prompt[strlen(prompt) - 1] == ':'
+		    || prompt[strlen(prompt) - 1] == '?') ? "" : ":");
+	  fflush (ttyfo);
+
+	  passphrase2 = read_password (ttyfi, ttyfo);
+	  fputc ('\n', ttyfo);
+	  if (! passphrase2)
+	    {
+	      done = -1;
+	      break;
+	    }
+
+	  if (strcmp (passphrase, passphrase2) == 0)
+	    done = 1;
+	  else
+	    fprintf (ttyfo, "*** %s%s%s ***\n",
+		     ALERT_START,
+		     pinentry->repeat_error_string
+		     ?: "Passphrases don't match.",
+		     NORMAL_RESTORE);
+
+	  secmem_free (passphrase2);
+	}
+
+      if (done == 1)
+	pinentry_setbuffer_use (pinentry, passphrase, 0);
+      else
+	secmem_free (passphrase);
+    }
+
+  return done;
 }
 
 
@@ -209,26 +466,16 @@
         }
     }
 
-  if (rc == 0)
+  if (! rc)
     {
       if (pinentry->pin)
-        rc = read_password (pinentry, ttyfi, ttyfo);
+	rc = password (pinentry, ttyfi, ttyfo);
       else
-        {
-          fprintf (ttyfo, "%s\n",
-                   pinentry->description? pinentry->description:"");
-          fflush (ttyfo);
-
-	  /* If pinentry->one_button is set, then
-	     pinentry->description contains an informative message,
-	     which the user needs to dismiss.  Since we are showing
-	     this in a terminal, there is no window to dismiss.  */
-          if (! pinentry->one_button)
-            rc = confirm (pinentry, ttyfi, ttyfo);
-        }
-      do_touch_file (pinentry);
+	rc = confirm (pinentry, ttyfi, ttyfo);
     }
 
+  do_touch_file (pinentry);
+
   if (pinentry->ttyname)
     {
       fclose (ttyfi);
