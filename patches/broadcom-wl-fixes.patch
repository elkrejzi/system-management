diff -Naur a/Makefile b/Makefile
--- a/Makefile	2014-06-26 12:42:08.000000000 +0200
+++ b/Makefile	2014-12-21 17:21:00.308477680 +0100
@@ -128,7 +128,8 @@
 
 EXTRA_LDFLAGS      := $(src)/lib/wlc_hybrid.o_shipped
 
-KBASE              ?= /lib/modules/`uname -r`
+KVER               ?= $(shell uname -r)
+KBASE              ?= /lib/modules/$(KVER)
 KBUILD_DIR         ?= $(KBASE)/build
 MDEST_DIR          ?= $(KBASE)/kernel/drivers/net/wireless
 
diff -Naur a/src/wl/sys/wl_cfg80211_hybrid.c b/src/wl/sys/wl_cfg80211_hybrid.c
--- a/src/wl/sys/wl_cfg80211_hybrid.c	2014-06-26 12:42:08.000000000 +0200
+++ b/src/wl/sys/wl_cfg80211_hybrid.c	2014-12-21 17:21:00.308477680 +0100
@@ -2071,7 +2071,11 @@
 			wl_get_assoc_ies(wl);
 			memcpy(&wl->bssid, &e->addr, ETHER_ADDR_LEN);
 			wl_update_bss_info(wl);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+			cfg80211_ibss_joined(ndev, (u8 *)&wl->bssid, &wl->conf->channel, GFP_KERNEL);
+#else
 			cfg80211_ibss_joined(ndev, (u8 *)&wl->bssid, GFP_KERNEL);
+#endif
 			set_bit(WL_STATUS_CONNECTED, &wl->status);
 			wl->profile->active = true;
 		}
@@ -2629,7 +2633,15 @@
 
 void wl_cfg80211_detach(struct net_device *ndev)
 {
-	struct wl_cfg80211_priv *wl = ndev_to_wl(ndev);
+	struct wl_cfg80211_priv *wl;
+	struct wireless_dev *wdev;
+	
+	wdev = ndev->ieee80211_ptr;
+	if (wdev == NULL) {
+                printk(KERN_ERR "[%s()] in ndev=%p: IEEE80211ptr=%p\n", __FUNCTION__, ndev, wdev);
+                return;
+        }
+	wl = ndev_to_wl(ndev);
 
 	wl_deinit_cfg80211_priv(wl);
 	wl_free_wdev(wl);
diff -Naur a/src/wl/sys/wl_dbg.h b/src/wl/sys/wl_dbg.h
--- a/src/wl/sys/wl_dbg.h	2014-06-26 12:42:08.000000000 +0200
+++ b/src/wl/sys/wl_dbg.h	2014-12-21 17:21:00.309477711 +0100
@@ -55,10 +55,12 @@
 
 #define WL_NONE(args)
 
+#define FORCE_TRACE_LEVEL(fmt, ...) do { printk(KERN_ERR fmt, ## __VA_ARGS__); } while (0) /* ## is GCC specific syntax to remove comma when single arg */
+
 #ifdef BCMDBG_ERR
 #define	WL_ERROR(args)		WL_PRINT(args)
 #else
-#define	WL_ERROR(args)
+#define	WL_ERROR(args)		FORCE_TRACE_LEVEL args
 #endif 
 #define	WL_TRACE(args)
 #define WL_APSTA_UPDN(args)
diff -Naur a/src/wl/sys/wl_linux.c b/src/wl/sys/wl_linux.c
--- a/src/wl/sys/wl_linux.c	2014-06-26 12:42:08.000000000 +0200
+++ b/src/wl/sys/wl_linux.c	2014-12-21 17:24:25.286415822 +0100
@@ -156,6 +156,8 @@
 static void wl_report_radio_state(wl_info_t *wl);
 #endif
 
+MODULE_LICENSE("MIXED/Proprietary");
+
 static struct pci_device_id wl_id_table[] =
 {
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
@@ -215,7 +217,7 @@
 #define to_str(s) #s
 #define quote_str(s) to_str(s)
 
-#define BRCM_WLAN_IFNAME eth%d
+#define BRCM_WLAN_IFNAME wlan%d
 
 static char intf_name[IFNAMSIZ] = quote_str(BRCM_WLAN_IFNAME);
 
@@ -722,7 +724,7 @@
 		WL_ALL_PASSIVE_ENAB(wl) ?  ", Passive Mode" : "", EPI_VERSION_STR);
 
 #ifdef BCMDBG
-	printf(" (Compiled in " SRCBASE " at " __TIME__ " on " __DATE__ ")");
+	printf(" (Compiled in " SRCBASE);
 #endif 
 	printf("\n");
 
@@ -878,7 +880,7 @@
 static SIMPLE_DEV_PM_OPS(wl_pm_ops, wl_suspend, wl_resume);
 #endif
 
-static struct pci_driver wl_pci_driver = {
+static struct pci_driver wl_pci_driver __refdata = {
 	.name =		"wl",
 	.probe =	wl_pci_probe,
 	.remove =	__devexit_p(wl_remove),
@@ -1270,6 +1272,7 @@
 		MFREE(wl->osh, wlif->dev, sizeof(struct net_device));
 #else
 		free_netdev(wlif->dev);
+		wlif->dev = NULL;
 #endif 
 	}
 
@@ -1307,7 +1310,11 @@
 	dev->priv = priv_link;
 #else
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+	dev = alloc_netdev(sizeof(priv_link_t), intf_name, NET_NAME_UNKNOWN, ether_setup);
+#else
 	dev = alloc_netdev(sizeof(priv_link_t), intf_name, ether_setup);
+#endif
 	if (!dev) {
 		WL_ERROR(("wl%d: %s: alloc_netdev failed\n",
 			(wl->pub)?wl->pub->unit:wlif->subunit, __FUNCTION__));
@@ -1651,11 +1658,7 @@
 	}
 
 	WL_LOCK(wl);
-	if (!capable(CAP_NET_ADMIN)) {
-		bcmerror = BCME_EPERM;
-	} else {
-		bcmerror = wlc_ioctl(wl->wlc, ioc.cmd, buf, ioc.len, wlif->wlcif);
-	}
+	bcmerror = wlc_ioctl(wl->wlc, ioc.cmd, buf, ioc.len, wlif->wlcif);
 	WL_UNLOCK(wl);
 
 done1:
@@ -2045,8 +2048,7 @@
 void
 wl_dump_ver(wl_info_t *wl, struct bcmstrbuf *b)
 {
-	bcm_bprintf(b, "wl%d: %s %s version %s\n", wl->pub->unit,
-		__DATE__, __TIME__, EPI_VERSION_STR);
+	bcm_bprintf(b, "wl%d: version %s\n", wl->pub->unit, EPI_VERSION_STR);
 }
 
 #if defined(BCMDBG)
@@ -2455,8 +2457,10 @@
 		p80211msg_t *phdr;
 
 		len = sizeof(p80211msg_t) + oskb->len - D11_PHY_HDR_LEN;
-		if ((skb = dev_alloc_skb(len)) == NULL)
+		if ((skb = dev_alloc_skb(len)) == NULL) {
+			WL_ERROR(("in %s:%d [%s()] dev_alloc_skb() failure!", __FILE__, __LINE__, __FUNCTION__));
 			return;
+		}
 
 		skb_put(skb, len);
 		phdr = (p80211msg_t*)skb->data;
@@ -2535,8 +2539,10 @@
 			rtap_len = sizeof(wl_radiotap_ht_brcm_2_t);
 
 		len = rtap_len + (oskb->len - D11_PHY_HDR_LEN);
-		if ((skb = dev_alloc_skb(len)) == NULL)
+		if ((skb = dev_alloc_skb(len)) == NULL) {
+			WL_ERROR(("in %s:%d [%s()] dev_alloc_skb() failure!", __FILE__, __LINE__, __FUNCTION__));
 			return;
+		}
 
 		skb_put(skb, len);
 
@@ -2664,8 +2670,10 @@
 			len += amsdu_len;
 		}
 
-		if ((skb = dev_alloc_skb(len)) == NULL)
+		if ((skb = dev_alloc_skb(len)) == NULL) {
+			WL_ERROR(("in %s:%d [%s()] dev_alloc_skb() failure!", __FILE__, __LINE__, __FUNCTION__));
 			return;
+		}
 
 		skb_put(skb, len);
 
@@ -2990,7 +2998,7 @@
 }
 
 void
-wl_set_monitor(wl_info_t *wl, int val)
+wl_set_monitor(wl_info_t *wl, int val) /* public => is called by wlc_hybrid.o_shipped */
 {
 	const char *devname;
 	wl_if_t *wlif;
@@ -3224,42 +3232,75 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 static int
 wl_proc_read(char *buffer, char **start, off_t offset, int length, int *eof, void *data)
+{
+	wl_info_t * wl = (wl_info_t *)data;
 #else
 static ssize_t
-wl_proc_read(struct file *filp, char __user *buffer, size_t length, loff_t *data)
-#endif
+wl_proc_read(struct file *filp, char __user *buffer, size_t length, loff_t *offp)
 {
-	wl_info_t * wl = (wl_info_t *)data;
-	int to_user;
-	int len;
+	wl_info_t * wl = PDE_DATA(file_inode(filp));
+#endif
+	int bcmerror, len;
+	int to_user = 0;
+	char tmp[8];
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 	if (offset > 0) {
 		*eof = 1;
 		return 0;
 	}
+#else
+	if (*offp > 0) { /* for example, stop: cat /proc/brcm_monitor0 */
+		return 0; /* 0 <=> EOF */
+	}
 #endif
 
-	if (!length) {
-		WL_ERROR(("%s: Not enough return buf space\n", __FUNCTION__));
-		return 0;
-	}
 	WL_LOCK(wl);
-	wlc_ioctl(wl->wlc, WLC_GET_MONITOR, &to_user, sizeof(int), NULL);
-	len = sprintf(buffer, "%d\n", to_user);
-	WL_UNLOCK(wl);
-	return len;
+	bcmerror = wlc_ioctl(wl->wlc, WLC_GET_MONITOR, &to_user, sizeof(int), NULL);
+ 	WL_UNLOCK(wl);
+
+	if (bcmerror != BCME_OK) {
+		WL_ERROR(("%s: GET_MONITOR failed with %d\n", __FUNCTION__, bcmerror));
+		return -EIO;
+	}
+
+ 	len = snprintf(tmp, ARRAY_SIZE(tmp), "%d\n", to_user);
+	tmp[ARRAY_SIZE(tmp) - 1] = '\0';
+	if (len >= ARRAY_SIZE(tmp)) {
+		printk(KERN_ERR "%s:%d [%s()] output would be truncated (ret=%d)!", __FILE__, __LINE__, __FUNCTION__, len);
+		return -ERANGE;
+	}
+	else if (len < 0) {
+		printk(KERN_ERR "%s:%d [%s()] unable to convert value (ret=%d)!", __FILE__, __LINE__, __FUNCTION__, len);
+		return len;
+	}
+	if (length < len) {
+		printk(KERN_ERR "%s:%d [%s()] user buffer is too small (at least=%d ; user=%d)!", __FILE__, __LINE__, __FUNCTION__, len, (int)length);
+		return -EMSGSIZE;
+	}
+	if (copy_to_user(buffer, tmp, len) != 0) {
+		printk(KERN_ERR "%s:%d [%s()] unable to copy data!", __FILE__, __LINE__, __FUNCTION__);
+		return -EFAULT;
+	}
+	
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	*offp += len;
+#endif
+
+ 	return len;
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 static int
 wl_proc_write(struct file *filp, const char *buff, unsigned long length, void *data)
+{
+	wl_info_t * wl = (wl_info_t *)data;
 #else
 static ssize_t
-wl_proc_write(struct file *filp, const char __user *buff, size_t length, loff_t *data)
-#endif
+wl_proc_write(struct file *filp, const char __user *buff, size_t length, loff_t *offp)
 {
-	wl_info_t * wl = (wl_info_t *)data;
+	wl_info_t * wl = PDE_DATA(file_inode(filp));
+#endif
 	int from_user = 0;
 	int bcmerror;
 
@@ -3270,7 +3311,11 @@
 	}
 	if (copy_from_user(&from_user, buff, 1)) {
 		WL_ERROR(("%s: copy from user failed\n", __FUNCTION__));
-		return -EIO;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
+ 		return -EIO;
+#else
+		return -EFAULT;
+#endif
 	}
 
 	if (from_user >= 0x30)
@@ -3280,10 +3325,15 @@
 	bcmerror = wlc_ioctl(wl->wlc, WLC_SET_MONITOR, &from_user, sizeof(int), NULL);
 	WL_UNLOCK(wl);
 
-	if (bcmerror < 0) {
+	if (bcmerror != BCME_OK) {
 		WL_ERROR(("%s: SET_MONITOR failed with %d\n", __FUNCTION__, bcmerror));
 		return -EIO;
 	}
+	
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) && 0 /* no need to update offset because this file should only trigger action... */
+	*offp += length;
+#endif
+
 	return length;
 }
 
@@ -3304,8 +3354,8 @@
 	if ((wl->proc_entry = create_proc_entry(tmp, 0644, NULL)) == NULL) {
 		WL_ERROR(("%s: create_proc_entry %s failed\n", __FUNCTION__, tmp));
 #else
-	if ((wl->proc_entry = proc_create(tmp, 0644, NULL, &wl_fops)) == NULL) {
-		WL_ERROR(("%s: proc_create %s failed\n", __FUNCTION__, tmp));
+	if ((wl->proc_entry = proc_create_data(tmp, 0644, NULL, &wl_fops, wl)) == NULL) {
+		WL_ERROR(("%s: proc_create_data %s failed\n", __FUNCTION__, tmp));
 #endif
 		ASSERT(0);
 		return -1;
