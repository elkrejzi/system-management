--- a/clients/simple-damage.c	2015-01-17 03:33:42.000000000 +0100
+++ b/clients/simple-damage.c	2015-02-17 22:50:57.823418715 +0100
@@ -642,7 +642,7 @@
 	xdg_shell_ping,
 };
 
-#define XDG_VERSION 4 /* The version of xdg-shell that we implement */
+#define XDG_VERSION 5 /* The version of xdg-shell that we implement */
 #ifdef static_assert
 static_assert(XDG_VERSION == XDG_SHELL_VERSION_CURRENT,
 	      "Interface version doesn't match implementation version");
--- a/clients/simple-egl.c	2015-01-21 02:22:16.000000000 +0100
+++ b/clients/simple-egl.c	2015-02-17 22:50:57.824418728 +0100
@@ -741,7 +741,7 @@
 	xdg_shell_ping,
 };
 
-#define XDG_VERSION 4 /* The version of xdg-shell that we implement */
+#define XDG_VERSION 5 /* The version of xdg-shell that we implement */
 #ifdef static_assert
 static_assert(XDG_VERSION == XDG_SHELL_VERSION_CURRENT,
 	      "Interface version doesn't match implementation version");
--- a/clients/simple-shm.c	2015-01-17 03:33:42.000000000 +0100
+++ b/clients/simple-shm.c	2015-02-17 22:50:57.824418728 +0100
@@ -352,7 +352,7 @@
 	xdg_shell_ping,
 };
 
-#define XDG_VERSION 4 /* The version of xdg-shell that we implement */
+#define XDG_VERSION 5 /* The version of xdg-shell that we implement */
 #ifdef static_assert
 static_assert(XDG_VERSION == XDG_SHELL_VERSION_CURRENT,
 	      "Interface version doesn't match implementation version");
--- a/clients/window.c	2015-01-17 03:33:42.000000000 +0100
+++ b/clients/window.c	2015-02-17 22:50:57.824418728 +0100
@@ -253,7 +253,7 @@
 	struct xdg_popup *xdg_popup;
 
 	struct window *parent;
-	struct wl_surface *last_parent_surface;
+	struct window *last_parent;
 
 	struct ivi_surface *ivi_surface;
 
@@ -4031,21 +4031,21 @@
 static void
 window_sync_parent(struct window *window)
 {
-	struct wl_surface *parent_surface;
+	struct xdg_surface *parent_surface;
 
 	if (!window->xdg_surface)
 		return;
 
+	if (window->parent == window->last_parent)
+		return;
+
 	if (window->parent)
-		parent_surface = window->parent->main_surface->surface;
+		parent_surface = window->parent->xdg_surface;
 	else
 		parent_surface = NULL;
 
-	if (parent_surface == window->last_parent_surface)
-		return;
-
 	xdg_surface_set_parent(window->xdg_surface, parent_surface);
-	window->last_parent_surface = parent_surface;
+	window->last_parent = window->parent;
 }
 
 static void
@@ -4727,7 +4727,7 @@
 }
 
 static void
-handle_popup_popup_done(void *data, struct xdg_popup *xdg_popup, uint32_t serial)
+handle_popup_popup_done(void *data, struct xdg_popup *xdg_popup)
 {
 	struct window *window = data;
 	struct menu *menu = window->main_surface->widget->user_data;
@@ -4840,8 +4840,7 @@
 						    input->seat,
 						    display_get_serial(window->display),
 						    window->x - ix,
-						    window->y - iy,
-						    0);
+						    window->y - iy);
 	fail_on_null(window->xdg_popup);
 
 	xdg_popup_set_user_data(window->xdg_popup, window);
@@ -5246,7 +5245,7 @@
 	xdg_shell_ping,
 };
 
-#define XDG_VERSION 4 /* The version of xdg-shell that we implement */
+#define XDG_VERSION 5 /* The version of xdg-shell that we implement */
 #ifdef static_assert
 static_assert(XDG_VERSION == XDG_SHELL_VERSION_CURRENT,
 	      "Interface version doesn't match implementation version");
--- a/desktop-shell/shell.c	2015-02-07 02:46:05.000000000 +0100
+++ b/desktop-shell/shell.c	2015-02-17 22:50:57.825418741 +0100
@@ -3059,20 +3059,18 @@
 	struct shell_seat *shseat =
 		container_of(listener,
 			     struct shell_seat, seat_destroy_listener);
-	struct shell_surface *shsurf, *prev = NULL;
+	struct shell_surface *shsurf, *next;
 
 	if (shseat->popup_grab.grab.interface == &popup_grab_interface) {
 		weston_pointer_end_grab(shseat->popup_grab.grab.pointer);
 		shseat->popup_grab.client = NULL;
 
-		wl_list_for_each(shsurf, &shseat->popup_grab.surfaces_list, popup.grab_link) {
+		wl_list_for_each_safe(shsurf, next,
+				      &shseat->popup_grab.surfaces_list,
+				      popup.grab_link) {
 			shsurf->popup.shseat = NULL;
-			if (prev) {
-				wl_list_init(&prev->popup.grab_link);
-			}
-			prev = shsurf;
+			wl_list_init(&shsurf->popup.grab_link);
 		}
-		wl_list_init(&prev->popup.grab_link);
 	}
 
 	wl_list_remove(&shseat->seat_destroy_listener.link);
@@ -3317,8 +3315,7 @@
 	if (shell_surface_is_wl_shell_surface(shsurf))
 		wl_shell_surface_send_popup_done(shsurf->resource);
 	else if (shell_surface_is_xdg_popup(shsurf))
-		xdg_popup_send_popup_done(shsurf->resource,
-					  shsurf->popup.serial);
+		xdg_popup_send_popup_done(shsurf->resource);
 }
 
 static void
@@ -3328,7 +3325,7 @@
 	struct shell_seat *shseat =
 	    container_of(grab, struct shell_seat, popup_grab.grab);
 	struct shell_surface *shsurf;
-	struct shell_surface *prev = NULL;
+	struct shell_surface *next;
 
 	if (pointer->grab->interface == &popup_grab_interface) {
 		weston_pointer_end_grab(grab->pointer);
@@ -3336,15 +3333,13 @@
 		shseat->popup_grab.grab.interface = NULL;
 		assert(!wl_list_empty(&shseat->popup_grab.surfaces_list));
 		/* Send the popup_done event to all the popups open */
-		wl_list_for_each(shsurf, &shseat->popup_grab.surfaces_list, popup.grab_link) {
+		wl_list_for_each_safe(shsurf, next,
+				      &shseat->popup_grab.surfaces_list,
+				      popup.grab_link) {
 			shell_surface_send_popup_done(shsurf);
 			shsurf->popup.shseat = NULL;
-			if (prev) {
-				wl_list_init(&prev->popup.grab_link);
-			}
-			prev = shsurf;
+			wl_list_init(&shsurf->popup.grab_link);
 		}
-		wl_list_init(&prev->popup.grab_link);
 		wl_list_init(&shseat->popup_grab.surfaces_list);
 	}
 }
@@ -3356,7 +3351,7 @@
 	struct shell_seat *shseat =
 	    container_of(grab, struct shell_seat, popup_grab.touch_grab);
 	struct shell_surface *shsurf;
-	struct shell_surface *prev = NULL;
+	struct shell_surface *next;
 
 	if (touch->grab->interface == &touch_popup_grab_interface) {
 		weston_touch_end_grab(grab->touch);
@@ -3364,48 +3359,87 @@
 		shseat->popup_grab.touch_grab.interface = NULL;
 		assert(!wl_list_empty(&shseat->popup_grab.surfaces_list));
 		/* Send the popup_done event to all the popups open */
-		wl_list_for_each(shsurf, &shseat->popup_grab.surfaces_list, popup.grab_link) {
+		wl_list_for_each_safe(shsurf, next,
+				      &shseat->popup_grab.surfaces_list,
+				      popup.grab_link) {
 			shell_surface_send_popup_done(shsurf);
 			shsurf->popup.shseat = NULL;
-			if (prev) {
-				wl_list_init(&prev->popup.grab_link);
-			}
-			prev = shsurf;
+			wl_list_init(&shsurf->popup.grab_link);
 		}
-		wl_list_init(&prev->popup.grab_link);
 		wl_list_init(&shseat->popup_grab.surfaces_list);
 	}
 }
 
-static void
-add_popup_grab(struct shell_surface *shsurf, struct shell_seat *shseat, int32_t type)
+static struct shell_surface *
+get_top_xdg_popup(struct shell_seat *shseat)
+{
+	struct shell_surface *shsurf;
+
+	if (wl_list_empty(&shseat->popup_grab.surfaces_list)) {
+		return NULL;
+	} else {
+		shsurf = container_of(shseat->popup_grab.surfaces_list.next,
+				      struct shell_surface,
+				      popup.grab_link);
+		assert(shell_surface_is_xdg_popup(shsurf));
+		return shsurf;
+	}
+}
+
+static int
+add_popup_grab(struct shell_surface *shsurf,
+	       struct shell_seat *shseat,
+	       int32_t type)
 {
 	struct weston_seat *seat = shseat->seat;
+	struct shell_surface *parent, *top_surface;
+
+	parent = get_shell_surface(shsurf->parent);
+	top_surface = get_top_xdg_popup(shseat);
+	if ((top_surface == NULL && !shell_surface_is_xdg_surface(parent)) ||
+	    (top_surface != NULL && parent != top_surface)) {
+		wl_resource_post_error(shsurf->owner->resource,
+				       XDG_POPUP_ERROR_NOT_THE_TOPMOST_POPUP,
+				       "xdg_popup was not created on the "
+				       "topmost popup");
+		return -1;
+	}
 
 	if (wl_list_empty(&shseat->popup_grab.surfaces_list)) {
 		shseat->popup_grab.type = type;
-		shseat->popup_grab.client = wl_resource_get_client(shsurf->resource);
+		shseat->popup_grab.client =
+			wl_resource_get_client(shsurf->resource);
 
 		if (type == POINTER) {
-			shseat->popup_grab.grab.interface = &popup_grab_interface;
-			/* We must make sure here that this popup was opened after
-			 * a mouse press, and not just by moving around with other
-			 * popups already open. */
+			shseat->popup_grab.grab.interface =
+				&popup_grab_interface;
+
+			/* We must make sure here that this popup was opened
+			 * after a mouse press, and not just by moving around
+			 * with other popups already open. */
 			if (shseat->seat->pointer->button_count > 0)
 				shseat->popup_grab.initial_up = 0;
 		} else if (type == TOUCH) {
-			shseat->popup_grab.touch_grab.interface = &touch_popup_grab_interface;
+			shseat->popup_grab.touch_grab.interface =
+				&touch_popup_grab_interface;
 		}
 
-		wl_list_insert(&shseat->popup_grab.surfaces_list, &shsurf->popup.grab_link);
+		wl_list_insert(&shseat->popup_grab.surfaces_list,
+			       &shsurf->popup.grab_link);
 
-		if (type == POINTER)
-			weston_pointer_start_grab(seat->pointer, &shseat->popup_grab.grab);
-		else if (type == TOUCH)
-			weston_touch_start_grab(seat->touch, &shseat->popup_grab.touch_grab);
+		if (type == POINTER) {
+			weston_pointer_start_grab(seat->pointer,
+						  &shseat->popup_grab.grab);
+		} else if (type == TOUCH) {
+			weston_touch_start_grab(seat->touch,
+						&shseat->popup_grab.touch_grab);
+		}
 	} else {
-		wl_list_insert(&shseat->popup_grab.surfaces_list, &shsurf->popup.grab_link);
+		wl_list_insert(&shseat->popup_grab.surfaces_list,
+			       &shsurf->popup.grab_link);
 	}
+
+	return 0;
 }
 
 static void
@@ -3413,6 +3447,15 @@
 {
 	struct shell_seat *shseat = shsurf->popup.shseat;
 
+	if (shell_surface_is_xdg_popup(shsurf) &&
+	    get_top_xdg_popup(shseat) != shsurf) {
+		wl_resource_post_error(shsurf->resource,
+				       XDG_POPUP_ERROR_NOT_THE_TOPMOST_POPUP,
+				       "xdg_popup was destroyed while it was "
+				       "not the topmost popup.");
+		return;
+	}
+
 	wl_list_remove(&shsurf->popup.grab_link);
 	wl_list_init(&shsurf->popup.grab_link);
 	if (wl_list_empty(&shseat->popup_grab.surfaces_list)) {
@@ -3426,7 +3469,7 @@
 	}
 }
 
-static void
+static int
 shell_map_popup(struct shell_surface *shsurf)
 {
 	struct shell_seat *shseat = shsurf->popup.shseat;
@@ -3441,14 +3484,18 @@
 
 	if (shseat->seat->pointer &&
 	    shseat->seat->pointer->grab_serial == shsurf->popup.serial) {
-		add_popup_grab(shsurf, shseat, POINTER);
+		if (add_popup_grab(shsurf, shseat, POINTER) != 0)
+			return -1;
 	} else if (shseat->seat->touch &&
 	           shseat->seat->touch->grab_serial == shsurf->popup.serial) {
-		add_popup_grab(shsurf, shseat, TOUCH);
+		if (add_popup_grab(shsurf, shseat, TOUCH) != 0)
+			return -1;
 	} else {
 		shell_surface_send_popup_done(shsurf);
 		shseat->popup_grab.client = NULL;
 	}
+
+	return 0;
 }
 
 static const struct wl_shell_surface_interface shell_surface_implementation = {
@@ -3712,14 +3759,14 @@
 		       struct wl_resource *parent_resource)
 {
 	struct shell_surface *shsurf = wl_resource_get_user_data(resource);
-	struct weston_surface *parent;
+	struct shell_surface *parent;
 
-	if (parent_resource)
+	if (parent_resource) {
 		parent = wl_resource_get_user_data(parent_resource);
-	else
-		parent = NULL;
-
-	shell_surface_set_parent(shsurf, parent);
+		shell_surface_set_parent(shsurf, parent->surface);
+	} else {
+		shell_surface_set_parent(shsurf, NULL);
+	}
 }
 
 static void
@@ -3938,6 +3985,13 @@
 };
 
 static void
+xdg_shell_destroy(struct wl_client *client,
+		  struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static void
 xdg_use_unstable_version(struct wl_client *client,
 			 struct wl_resource *resource,
 			 int32_t version)
@@ -4045,7 +4099,20 @@
 		 uint32_t serial,
 		 int32_t x, int32_t y)
 {
-	struct shell_surface *shsurf;
+	struct shell_surface *shsurf, *parent_shsurf;
+
+	/* Verify that we are creating the top most popup when mapping,
+	 * as its not until then we know whether it was mapped as most
+	 * top level or not. */
+
+	parent_shsurf = get_shell_surface(parent);
+	if (!shell_surface_is_xdg_popup(parent_shsurf) &&
+	    !shell_surface_is_xdg_surface(parent_shsurf)) {
+		wl_resource_post_error(owner->resource,
+				       XDG_POPUP_ERROR_INVALID_PARENT,
+				       "xdg_popup parent was invalid");
+		return NULL;
+	}
 
 	shsurf = create_common_surface(owner, shell, surface, client);
 	if (!shsurf)
@@ -4069,7 +4136,7 @@
 		  struct wl_resource *parent_resource,
 		  struct wl_resource *seat_resource,
 		  uint32_t serial,
-		  int32_t x, int32_t y, uint32_t flags)
+		  int32_t x, int32_t y)
 {
 	struct weston_surface *surface =
 		wl_resource_get_user_data(surface_resource);
@@ -4134,6 +4201,7 @@
 }
 
 static const struct xdg_shell_interface xdg_implementation = {
+	xdg_shell_destroy,
 	xdg_use_unstable_version,
 	xdg_get_xdg_surface,
 	xdg_get_xdg_popup,
@@ -4149,14 +4217,14 @@
 	struct wl_resource *resource = _target;
 	struct shell_client *sc = wl_resource_get_user_data(resource);
 
-	if (opcode != 0) {
+	if (opcode != 1 /* XDG_SHELL_USE_UNSTABLE_VERSION */) {
 		wl_resource_post_error(resource,
 				       WL_DISPLAY_ERROR_INVALID_OBJECT,
 				       "must call use_unstable_version first");
 		return 0;
 	}
 
-#define XDG_SERVER_VERSION 4
+#define XDG_SERVER_VERSION 5
 
 	static_assert(XDG_SERVER_VERSION == XDG_SHELL_VERSION_CURRENT,
 		      "shell implementation doesn't match protocol version");
@@ -5447,7 +5515,8 @@
 		}
 		break;
 	case SHELL_SURFACE_POPUP:
-		shell_map_popup(shsurf);
+		if (shell_map_popup(shsurf) != 0)
+			return;
 		break;
 	case SHELL_SURFACE_NONE:
 		weston_view_set_position(shsurf->view,
--- a/protocol/xdg-shell.xml	2015-01-17 03:33:42.000000000 +0100
+++ b/protocol/xdg-shell.xml	2015-02-17 22:50:57.825418741 +0100
@@ -31,11 +31,10 @@
 
   <interface name="xdg_shell" version="1">
     <description summary="create desktop-style surfaces">
-      This interface is implemented by servers that provide
-      desktop-style user interfaces.
-
-      It allows clients to associate a xdg_surface with
-      a basic surface.
+      xdg_shell allows clients to turn a wl_surface into a "real window"
+      which can be dragged, resized, stacked, and moved around by the
+      user. Everything about this interface is suited towards traditional
+      desktop environments.
     </description>
 
     <enum name="version">
@@ -45,13 +44,24 @@
 	they implement using static_assert to ensure the protocol and
 	implementation versions match.
       </description>
-      <entry name="current" value="4" summary="Always the latest version"/>
+      <entry name="current" value="5" summary="Always the latest version"/>
     </enum>
 
     <enum name="error">
       <entry name="role" value="0" summary="given wl_surface has another role"/>
     </enum>
 
+    <request name="destroy" type="destructor">
+      <description summary="destroy xdg_shell">
+        Destroy this xdg_shell object.
+
+        Destroying a bound xdg_shell object while there are surfaces
+        still alive with roles from this interface is illegal and will
+        result in a protocol error. Make sure to destroy all surfaces
+        before destroying this object.
+      </description>
+    </request>
+
     <request name="use_unstable_version">
       <description summary="enable use of this unstable version">
 	Negotiate the unstable version of the interface.  This
@@ -65,36 +75,28 @@
 
     <request name="get_xdg_surface">
       <description summary="create a shell surface from a surface">
-	Create a shell surface for an existing surface.
-
-	This request gives the surface the role of xdg_surface. If the
-	surface already has another role, it raises a protocol error.
-
-	Only one shell or popup surface can be associated with a given
-	surface.
+	This creates an xdg_surface for the given surface and gives it the
+	xdg_surface role. See the documentation of xdg_surface for more details.
       </description>
       <arg name="id" type="new_id" interface="xdg_surface"/>
       <arg name="surface" type="object" interface="wl_surface"/>
     </request>
 
     <request name="get_xdg_popup">
-      <description summary="create a shell surface from a surface">
-	Create a popup surface for an existing surface.
+      <description summary="create a popup for a surface">
+	This creates an xdg_popup for the given surface and gives it the
+	xdg_popup role. See the documentation of xdg_popup for more details.
 
-	This request gives the surface the role of xdg_popup. If the
-	surface already has another role, it raises a protocol error.
-
-	Only one shell or popup surface can be associated with a given
-	surface.
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event.
       </description>
       <arg name="id" type="new_id" interface="xdg_popup"/>
       <arg name="surface" type="object" interface="wl_surface"/>
       <arg name="parent" type="object" interface="wl_surface"/>
-      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat whose pointer is used"/>
-      <arg name="serial" type="uint" summary="serial of the implicit grab on the pointer"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
       <arg name="x" type="int"/>
       <arg name="y" type="int"/>
-      <arg name="flags" type="uint"/>
     </request>
 
     <event name="ping">
@@ -108,7 +110,7 @@
         respond to the ping request, or in what timeframe. Clients should
         try to respond in a reasonable amount of time.
       </description>
-      <arg name="serial" type="uint" summary="pass this to the callback"/>
+      <arg name="serial" type="uint" summary="pass this to the pong request"/>
     </event>
 
     <request name="pong">
@@ -121,38 +123,34 @@
   </interface>
 
   <interface name="xdg_surface" version="1">
-
-    <description summary="desktop-style metadata interface">
+    <description summary="A desktop window">
       An interface that may be implemented by a wl_surface, for
       implementations that provide a desktop-style user interface.
 
       It provides requests to treat surfaces like windows, allowing to set
       properties like maximized, fullscreen, minimized, and to move and resize
       them, and associate metadata like title and app id.
-
-      On the server side the object is automatically destroyed when
-      the related wl_surface is destroyed.  On client side,
-      xdg_surface.destroy() must be called before destroying
-      the wl_surface object.
     </description>
 
     <request name="destroy" type="destructor">
-      <description summary="remove xdg_surface interface">
-	The xdg_surface interface is removed from the wl_surface object
-	that was turned into a xdg_surface with
-	xdg_shell.get_xdg_surface request. The xdg_surface properties,
-	like maximized and fullscreen, are lost. The wl_surface loses
-	its role as a xdg_surface. The wl_surface is unmapped.
+      <description summary="Destroy the xdg_surface">
+	Unmap and destroy the window. The window will be effectively
+	hidden from the user's point of view, and all state like
+	maximization, fullscreen, and so on, will be lost.
       </description>
     </request>
 
     <request name="set_parent">
-      <description summary="surface is a child of another surface">
-	Child surfaces are stacked above their parents, and will be
-	unmapped if the parent is unmapped too. They should not appear
-	on task bars and alt+tab.
+      <description summary="set the parent of this surface">
+	Set the "parent" of this surface. This window should be stacked
+	above a parent. The parent surface must be mapped as long as this
+	surface is mapped.
+
+	Parent windows should be set on dialogs, toolboxes, or other
+	"auxilliary" surfaces, so that the parent is raised when the dialog
+	is raised.
       </description>
-      <arg name="parent" type="object" interface="wl_surface" allow-null="true"/>
+      <arg name="parent" type="object" interface="xdg_surface" allow-null="true"/>
     </request>
 
     <request name="set_title">
@@ -169,14 +167,19 @@
     </request>
 
     <request name="set_app_id">
-      <description summary="set surface class">
-	Set an id for the surface.
+      <description summary="set application ID">
+	Set an application identifier for the surface.
 
-	The app id identifies the general class of applications to which
-	the surface belongs.
+	The app ID identifies the general class of applications to which
+	the surface belongs. The compositor can use this to group multiple
+	applications together, or to determine how to launch a new
+	application.
+
+	See the desktop-entry specification [0] for more details on
+	application identifiers and how they relate to well-known DBus
+	names and .desktop files.
 
-	It should be the ID that appears in the new desktop entry
-	specification, the interface name.
+	[0] http://standards.freedesktop.org/desktop-entry-spec/
       </description>
       <arg name="app_id" type="string"/>
     </request>
@@ -188,29 +191,32 @@
         user a menu that they can use to maximize or minimize the window.
 
         This request asks the compositor to pop up such a window menu at
-        the given position, relative to the parent surface. There are
-        no guarantees as to what the window menu contains.
+        the given position, relative to the local surface coordinates of
+        the parent surface. There are no guarantees as to what menu items
+        the window menu contains.
 
-        Your surface must have focus on the seat passed in to pop up the
-        window menu.
+        This request must be used in response to some sort of user action
+        like a button press, key press, or touch down event.
       </description>
 
-      <arg name="seat" type="object" interface="wl_seat" summary="the seat to pop the window up on"/>
-      <arg name="serial" type="uint" summary="serial of the event to pop up the window for"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
       <arg name="x" type="int" summary="the x position to pop up the window menu at"/>
       <arg name="y" type="int" summary="the y position to pop up the window menu at"/>
     </request>
 
     <request name="move">
       <description summary="start an interactive move">
-	Start a pointer-driven move of the surface.
+	Start an interactive, user-driven move of the surface.
+
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event.
 
-	This request must be used in response to a button press event.
 	The server may ignore move requests depending on the state of
 	the surface (e.g. fullscreen or maximized).
       </description>
-      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat whose pointer is used"/>
-      <arg name="serial" type="uint" summary="serial of the implicit grab on the pointer"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
     </request>
 
     <enum name="resize_edge">
@@ -233,14 +239,16 @@
 
     <request name="resize">
       <description summary="start an interactive resize">
-	Start a pointer-driven resizing of the surface.
+	Start a user-driven, interactive resize of the surface.
+
+	This request must be used in response to some sort of user action
+	like a button press, key press, or touch down event.
 
-	This request must be used in response to a button press event.
 	The server may ignore resize requests depending on the state of
 	the surface (e.g. fullscreen or maximized).
       </description>
-      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat whose pointer is used"/>
-      <arg name="serial" type="uint" summary="serial of the implicit grab on the pointer"/>
+      <arg name="seat" type="object" interface="wl_seat" summary="the wl_seat of the user event"/>
+      <arg name="serial" type="uint" summary="the serial of the user event"/>
       <arg name="edges" type="uint" summary="which edge or corner is being dragged"/>
     </request>
 
@@ -288,16 +296,21 @@
 
     <event name="configure">
       <description summary="suggest a surface change">
-	The configure event asks the client to resize its surface.
+	The configure event asks the client to resize its surface or to
+	change its state.
 
 	The width and height arguments specify a hint to the window
-        about how its surface should be resized in window geometry
-        coordinates. The states listed in the event specify how the
-        width/height arguments should be interpreted.
-
-        A client should arrange a new surface, and then send a
-        ack_configure request with the serial sent in this configure
-        event before attaching a new surface.
+	about how its surface should be resized in window geometry
+	coordinates.
+
+	The states listed in the event specify how the width/height
+	arguments should be interpreted, and possibly how it should be
+	drawn.
+
+	Clients should arrange their surface for the new size and
+	states, and then send a ack_configure request with the serial
+	sent in this configure event at some point before committing
+	the new surface.
 
 	If the client receives multiple configure events before it
         can respond to one, it is free to discard all but the last
@@ -312,14 +325,19 @@
 
     <request name="ack_configure">
       <description summary="ack a configure event">
-        When a configure event is received, a client should then ack it
-        using the ack_configure request to ensure that the compositor
-        knows the client has seen the event.
+        When a configure event is received, if a client commits the
+        surface in response to the configure event, then the client
+        must make a ack_configure request before the commit request,
+        passing along the serial of the configure event.
+
+        The compositor might use this information to move a surface
+        to the top left only when the client has drawn itself for
+        the maximized or fullscreen state.
 
-        By this point, the state is confirmed, and the next attach should
-        contain the buffer drawn for the configure event you are acking.
+        If the client receives multiple configure events before it
+        can respond to one, it only has to ack the last configure event.
       </description>
-      <arg name="serial" type="uint" summary="a serial to configure for"/>
+      <arg name="serial" type="uint" summary="the serial from the configure event"/>
     </request>
 
     <request name="set_window_geometry">
@@ -329,15 +347,20 @@
         portions like drop-shadows which should be ignored for the
         purposes of aligning, placing and constraining windows.
 
-        The default value is the full bounds of the surface, including any
-        subsurfaces. Once the window geometry of the surface is set once,
-        it is not possible to unset it, and it will remain the same until
+        Once the window geometry of the surface is set once, it is not
+        possible to unset it, and it will remain the same until
         set_window_geometry is called again, even if a new subsurface or
         buffer is attached.
 
+        If never set, the value is the full bounds of the surface,
+        including any subsurfaces. This updates dynamically on every
+        commit. This unset mode is meant for extremely simple clients.
+
         If responding to a configure event, the window geometry in here
         must respect the sizing negotiations specified by the states in
         the configure event.
+
+        The width and height must be greater than zero.
       </description>
       <arg name="x" type="int"/>
       <arg name="y" type="int"/>
@@ -360,7 +383,18 @@
     </request>
     <request name="unset_fullscreen" />
 
-    <request name="set_minimized" />
+    <request name="set_minimized">
+      <description summary="set the window as minimized">
+	Request that the compositor minimize your surface. There is no
+	way to know if the surface is currently minimized, nor is there
+	any way to unset minimization on this surface.
+
+	If you are looking to throttle redrawing when minimized, please
+	instead use the wl_surface.frame event for this, as this will
+	also work with live previews on windows in Alt-Tab, Expose or
+	similar compositor features.
+      </description>
+    </request>
 
     <event name="close">
       <description summary="surface wants to be closed">
@@ -377,45 +411,74 @@
   </interface>
 
   <interface name="xdg_popup" version="1">
-    <description summary="desktop-style metadata interface">
-      An interface that may be implemented by a wl_surface, for
-      implementations that provide a desktop-style popups/menus. A popup
-      surface is a transient surface with an added pointer grab.
-
-      An existing implicit grab will be changed to owner-events mode,
-      and the popup grab will continue after the implicit grab ends
-      (i.e. releasing the mouse button does not cause the popup to be
-      unmapped).
-
-      The popup grab continues until the window is destroyed or a mouse
-      button is pressed in any other clients window. A click in any of
-      the clients surfaces is reported as normal, however, clicks in
-      other clients surfaces will be discarded and trigger the callback.
-
-      The x and y arguments specify the locations of the upper left
-      corner of the surface relative to the upper left corner of the
-      parent surface, in surface local coordinates.
-
-      xdg_popup surfaces are always transient for another surface.
+    <description summary="short-lived, popup surfaces for menus">
+      A popup surface is a short-lived, temporary surface that can be
+      used to implement menus. It takes an explicit grab on the surface
+      that will be dismissed when the user dismisses the popup. This can
+      be done by the user clicking outside the surface, using the keyboard,
+      or even locking the screen through closing the lid or a timeout.
+
+      When the popup is dismissed, a popup_done event will be sent out,
+      and at the same time the surface will be unmapped. The xdg_popup
+      object is now inert and cannot be reactivated, so clients should
+      destroy it. Explicitly destroying the xdg_popup object will also
+      dismiss the popup and unmap the surface.
+
+      Clients will receive events for all their surfaces during this
+      grab (which is an "owner-events" grab in X11 parlance). This is
+      done so that users can navigate through submenus and other
+      "nested" popup windows without having to dismiss the topmost
+      popup.
+
+      Clients that want to dismiss the popup when another surface of
+      their own is clicked should dismiss the popup using the destroy
+      request.
+
+      The parent surface must have either an xdg_surface or xdg_popup
+      role.
+
+      Specifying an xdg_popup for the parent means that the popups are
+      nested, with this popup now being the topmost popup. Nested
+      popups must be destroyed in the reverse order they were created
+      in, e.g. the only popup you are allowed to destroy at all times
+      is the topmost one.
+
+      If there is an existing popup when creating a new popup, the
+      parent must be the current topmost popup.
+
+      A parent surface must be mapped before the new popup is mapped.
+
+      When compositors choose to dismiss a popup, they will likely
+      dismiss every nested popup as well.
+
+      The x and y arguments specify where the top left of the popup
+      should be placed, relative to the local surface coordinates of the
+      parent surface.
     </description>
 
+    <enum name="error">
+      <description summary="xdg_popup error values">
+	These errors can be emitted in response to xdg_popup requests.
+      </description>
+      <entry name="not_the_topmost_popup" value="0" summary="The client tried to map or destroy a non-toplevel popup"/>
+      <entry name="invalid_parent" value="1" summary="The client specified an invalid parent surface"/>
+    </enum>
+
     <request name="destroy" type="destructor">
-      <description summary="remove xdg_surface interface">
-	The xdg_surface interface is removed from the wl_surface object
-	that was turned into a xdg_surface with
-	xdg_shell.get_xdg_surface request. The xdg_surface properties,
-	like maximized and fullscreen, are lost. The wl_surface loses
-	its role as a xdg_surface. The wl_surface is unmapped.
+      <description summary="remove xdg_popup interface">
+	This destroys the popup. Explicitly destroying the xdg_popup
+	object will also dismiss the popup, and unmap the surface.
+
+	If this xdg_popup is not the "topmost" popup, a protocol error
+	will be sent.
       </description>
     </request>
 
     <event name="popup_done">
       <description summary="popup interaction is done">
-	The popup_done event is sent out when a popup grab is broken,
-	that is, when the users clicks a surface that doesn't belong
-	to the client owning the popup surface.
+	The popup_done event is sent out when a popup is dismissed
+	by the compositor.
       </description>
-      <arg name="serial" type="uint" summary="serial of the implicit grab on the pointer"/>
     </event>
 
   </interface>
