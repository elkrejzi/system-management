--- a/clients/clickdot.c	2015-01-16 17:26:57.000000000 +0100
+++ b/clients/clickdot.c	2015-01-16 18:04:36.779958649 +0100
@@ -24,6 +24,7 @@
 
 #include "config.h"
 
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -61,6 +62,8 @@
 	struct input *cursor_timeout_input;
 	int cursor_timeout_fd;
 	struct task cursor_timeout_task;
+
+	bool pointer_confined;
 };
 
 static void
@@ -205,16 +208,31 @@
 }
 
 static void
+toggle_pointer_confine(struct clickdot *clickdot, struct input *input)
+{
+	if (clickdot->pointer_confined) {
+		window_unconfine_pointer(clickdot->window);
+	} else {
+		window_confine_pointer(clickdot->window, clickdot->widget,
+				       input);
+	}
+
+	clickdot->pointer_confined = !clickdot->pointer_confined;
+}
+
+static void
 button_handler(struct widget *widget,
 	       struct input *input, uint32_t time,
 	       uint32_t button,
 	       enum wl_pointer_button_state state, void *data)
 {
 	struct clickdot *clickdot = data;
+	bool is_pressed = state == WL_POINTER_BUTTON_STATE_PRESSED;
 
-	if (state == WL_POINTER_BUTTON_STATE_PRESSED && button == BTN_LEFT)
+	if (is_pressed && button == BTN_LEFT)
 		input_get_position(input, &clickdot->dot.x, &clickdot->dot.y);
-
+	else if (is_pressed && button == BTN_RIGHT)
+		toggle_pointer_confine(clickdot, input);
 	widget_schedule_redraw(widget);
 }
 
@@ -282,6 +300,14 @@
 				CURSOR_LEFT_PTR);
 }
 
+static void
+pointer_unconfined(struct window *window, struct input *input, void *data)
+{
+	struct clickdot *clickdot = data;
+
+	clickdot->pointer_confined = false;
+}
+
 static struct clickdot *
 clickdot_create(struct display *display)
 {
@@ -298,6 +324,8 @@
 	window_set_user_data(clickdot->window, clickdot);
 	window_set_keyboard_focus_handler(clickdot->window,
 					  keyboard_focus_handler);
+	window_set_pointer_unconfined_handler(clickdot->window,
+					      pointer_unconfined);
 
 	widget_set_redraw_handler(clickdot->widget, redraw_handler);
 	widget_set_button_handler(clickdot->widget, button_handler);
--- a/clients/resizor.c	2015-01-16 17:26:57.000000000 +0100
+++ b/clients/resizor.c	2015-01-16 18:04:36.779958649 +0100
@@ -22,6 +22,7 @@
 
 #include "config.h"
 
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,6 +50,10 @@
 	struct spring width;
 	struct spring height;
 	struct wl_callback *frame_callback;
+	bool pointer_locked;
+	struct input *locked_input;
+	float pointer_x;
+	float pointer_y;
 };
 
 static void
@@ -219,20 +224,158 @@
 }
 
 static void
+locked_pointer_handle_motion(struct window *window,
+			     struct input *input,
+			     uint32_t time,
+			     float dx,
+			     float dy,
+			     void *data)
+{
+	struct resizor *resizor = data;
+
+	resizor->width.current += dx;
+	resizor->width.previous = resizor->width.current;
+	resizor->width.target = resizor->width.current;
+
+	resizor->height.current += dy;
+	resizor->height.previous = resizor->height.current;
+	resizor->height.target = resizor->height.current;
+
+	widget_schedule_resize(resizor->widget,
+			       resizor->width.current,
+			       resizor->height.current);
+}
+
+static void
+handle_pointer_locked(struct window *window, struct input *input, void *data)
+{
+	struct resizor *resizor = data;
+
+	resizor->pointer_locked = true;
+	input_set_pointer_image(input, CURSOR_BLANK);
+}
+
+static void
+handle_pointer_unlocked(struct window *window, struct input *input, void *data)
+{
+	struct resizor *resizor = data;
+
+	resizor->pointer_locked = false;
+	input_set_pointer_image(input, CURSOR_LEFT_PTR);
+}
+
+static const struct wl_callback_listener locked_pointer_frame_listener;
+
+static void
+locked_pointer_frame_callback(void *data,
+			      struct wl_callback *callback,
+			      uint32_t time)
+{
+	struct resizor *resizor = data;
+	struct wl_surface *surface;
+	struct rectangle allocation;
+	float x, y;
+
+	if (resizor->pointer_locked) {
+		widget_get_allocation(resizor->widget, &allocation);
+
+		x = resizor->pointer_x + (allocation.width - allocation.x);
+		y = resizor->pointer_y + (allocation.height - allocation.y);
+
+		widget_set_locked_pointer_cursor_hint(resizor->widget, x, y);
+	}
+
+	wl_callback_destroy(callback);
+
+	surface = window_get_wl_surface(resizor->window);
+	callback = wl_surface_frame(surface);
+	wl_callback_add_listener(callback,
+				 &locked_pointer_frame_listener,
+				 resizor);
+}
+
+static const struct wl_callback_listener locked_pointer_frame_listener = {
+	locked_pointer_frame_callback
+};
+
+static void
 button_handler(struct widget *widget,
 	       struct input *input, uint32_t time,
 	       uint32_t button, enum wl_pointer_button_state state, void *data)
 {
 	struct resizor *resizor = data;
+	struct rectangle allocation;
+	struct wl_surface *surface;
+	struct wl_callback *callback;
 
-	switch (button) {
-	case BTN_RIGHT:
-		if (state == WL_POINTER_BUTTON_STATE_PRESSED)
-			show_menu(resizor, input, time);
-		break;
+	if (button == BTN_RIGHT && state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		show_menu(resizor, input, time);
+	} else if (button == BTN_LEFT &&
+		   state == WL_POINTER_BUTTON_STATE_PRESSED) {
+		window_get_allocation(resizor->window, &allocation);
+
+		resizor->width.current = allocation.width;
+		resizor->width.previous = allocation.width;
+		resizor->width.target = allocation.width;
+
+		resizor->height.current = allocation.height;
+		resizor->height.previous = allocation.height;
+		resizor->height.target = allocation.height;
+
+		window_lock_pointer(resizor->window, input);
+		window_set_pointer_locked_handler(resizor->window,
+						  handle_pointer_locked);
+		window_set_pointer_unlocked_handler(resizor->window,
+						    handle_pointer_unlocked);
+		resizor->locked_input = input;
+
+		surface = window_get_wl_surface(resizor->window);
+		callback = wl_surface_frame(surface);
+		wl_callback_add_listener(callback,
+					 &locked_pointer_frame_listener,
+					 resizor);
+	} else if (button == BTN_LEFT &&
+		   state == WL_POINTER_BUTTON_STATE_RELEASED) {
+		input_set_pointer_image(input, CURSOR_LEFT_PTR);
+		window_unlock_pointer(resizor->window);
 	}
 }
 
+static void
+set_cursor_inv_offset(struct resizor *resizor, float x, float y)
+{
+	struct rectangle allocation;
+
+	widget_get_allocation(resizor->widget, &allocation);
+
+	resizor->pointer_x = x - (allocation.width - allocation.x);
+	resizor->pointer_y = y - (allocation.height - allocation.y);
+}
+
+static int
+enter_handler(struct widget *widget,
+	      struct input *input,
+	      float x, float y, void *data)
+{
+	struct resizor *resizor = data;
+
+	set_cursor_inv_offset(resizor, x , y);
+
+	return CURSOR_LEFT_PTR;
+}
+
+static int
+motion_handler(struct widget *widget,
+	       struct input *input, uint32_t time,
+	       float x, float y, void *data)
+{
+	struct resizor *resizor = data;
+
+	set_cursor_inv_offset(resizor, x , y);
+
+	return CURSOR_LEFT_PTR;
+}
+
 static struct resizor *
 resizor_create(struct display *display)
 {
@@ -250,6 +393,12 @@
 	window_set_keyboard_focus_handler(resizor->window,
 					  keyboard_focus_handler);
 
+	widget_set_enter_handler(resizor->widget, enter_handler);
+	widget_set_motion_handler(resizor->widget, motion_handler);
+
+	window_set_locked_pointer_motion_handler(
+			resizor->window, locked_pointer_handle_motion);
+
 	widget_set_button_handler(resizor->widget, button_handler);
 
 	resizor->height.previous = 400;
--- a/clients/window.c	2015-01-16 17:26:57.000000000 +0100
+++ b/clients/window.c	2015-01-16 18:04:36.777958617 +0100
@@ -23,6 +23,7 @@
 
 #include "config.h"
 
+#include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -68,6 +69,8 @@
 #include "xdg-shell-client-protocol.h"
 #include "text-cursor-position-client-protocol.h"
 #include "workspaces-client-protocol.h"
+#include "pointer-lock-client-protocol.h"
+#include "relative-pointer-client-protocol.h"
 #include "../shared/os-compatibility.h"
 
 #include "window.h"
@@ -96,6 +99,8 @@
 	struct workspace_manager *workspace_manager;
 	struct xdg_shell *xdg_shell;
 	struct ivi_application *ivi_application; /* ivi style shell */
+	struct _wl_relative_pointer_manager *relative_pointer_manager;
+	struct _wl_pointer_lock *pointer_lock;
 	EGLDisplay dpy;
 	EGLConfig argb_config;
 	EGLContext argb_ctx;
@@ -248,6 +253,8 @@
 	window_output_handler_t output_handler;
 	window_state_changed_handler_t state_changed_handler;
 
+	window_locked_pointer_motion_handler_t locked_pointer_motion_handler;
+
 	struct surface *main_surface;
 	struct xdg_surface *xdg_surface;
 	struct xdg_popup *xdg_popup;
@@ -262,6 +269,17 @@
 	/* struct surface::link, contains also main_surface */
 	struct wl_list subsurface_list;
 
+	struct _wl_relative_pointer *relative_pointer;
+	struct _wl_locked_pointer *locked_pointer;
+	struct input *locked_input;
+	bool pointer_locked;
+	locked_pointer_locked_handler_t pointer_locked_handler;
+	locked_pointer_unlocked_handler_t pointer_unlocked_handler;
+	confined_pointer_confined_handler_t pointer_confined_handler;
+	confined_pointer_unconfined_handler_t pointer_unconfined_handler;
+
+	struct _wl_confined_pointer *confined_pointer;
+
 	void *user_data;
 	struct wl_list link;
 };
@@ -4390,6 +4408,43 @@
 }
 
 void
+window_set_pointer_locked_handler(struct window *window,
+				  locked_pointer_locked_handler_t locked)
+{
+	window->pointer_locked_handler = locked;
+}
+
+void
+window_set_pointer_unlocked_handler(struct window *window,
+				    locked_pointer_unlocked_handler_t unlocked)
+{
+	window->pointer_unlocked_handler = unlocked;
+}
+
+void
+window_set_pointer_confined_handler(
+	struct window *window, confined_pointer_confined_handler_t confined)
+{
+	window->pointer_confined_handler = confined;
+}
+
+void
+window_set_pointer_unconfined_handler(
+	struct window *window,
+	confined_pointer_unconfined_handler_t unconfined)
+{
+	window->pointer_unconfined_handler = unconfined;
+}
+
+void
+window_set_locked_pointer_motion_handler(
+	struct window *window,
+	window_locked_pointer_motion_handler_t handler)
+{
+	window->locked_pointer_motion_handler = handler;
+}
+
+void
 window_set_title(struct window *window, const char *title)
 {
 	free(window->title);
@@ -4431,6 +4486,236 @@
 }
 
 static void
+relative_pointer_handle_motion(void *data, struct _wl_relative_pointer *pointer,
+			       uint32_t time,
+			       wl_fixed_t dx, wl_fixed_t dy,
+			       wl_fixed_t dx_noaccel, wl_fixed_t dy_noaccel)
+{
+	struct input *input = data;
+	struct window *window = input->pointer_focus;
+
+	if (window->locked_pointer_motion_handler &&
+	    window->pointer_locked) {
+		window->locked_pointer_motion_handler(
+				window, input, time,
+				wl_fixed_to_double(dx),
+				wl_fixed_to_double(dy),
+				window->user_data);
+	}
+}
+
+static const struct _wl_relative_pointer_listener relative_pointer_listener = {
+	relative_pointer_handle_motion,
+};
+
+static void
+locked_pointer_locked(void *data,
+		      struct _wl_locked_pointer *locked_pointer,
+		      uint32_t serial)
+{
+	struct input *input = data;
+	struct window *window = input->pointer_focus;
+
+	window->pointer_locked = true;
+
+	if (window->pointer_locked_handler) {
+		window->pointer_locked_handler(window,
+					       input,
+					       window->user_data);
+	}
+}
+
+static void
+locked_pointer_unlocked(void *data,
+			struct _wl_locked_pointer *locked_pointer)
+{
+	struct input *input = data;
+	struct window *window = input->pointer_focus;
+
+	window_unlock_pointer(window);
+
+	if (window->pointer_unlocked_handler) {
+		window->pointer_unlocked_handler(window,
+						 input,
+						 window->user_data);
+	}
+}
+
+static const struct _wl_locked_pointer_listener locked_pointer_listener = {
+	locked_pointer_locked,
+	locked_pointer_unlocked,
+};
+
+int
+window_lock_pointer(struct window *window, struct input *input)
+{
+	struct _wl_relative_pointer_manager *relative_pointer_manager =
+		window->display->relative_pointer_manager;
+	struct _wl_pointer_lock *pointer_lock = window->display->pointer_lock;
+	struct _wl_relative_pointer *relative_pointer;
+	struct _wl_locked_pointer *locked_pointer;
+
+	if (!window->display->relative_pointer_manager)
+		return -1;
+
+	if (!window->display->pointer_lock)
+		return -1;
+
+	if (window->locked_pointer)
+		return -1;
+
+	if (window->confined_pointer)
+		return -1;
+
+	if (!input->pointer)
+		return -1;
+
+	relative_pointer = _wl_relative_pointer_manager_get_relative_pointer(
+		relative_pointer_manager, input->seat);
+	_wl_relative_pointer_add_listener(relative_pointer,
+					  &relative_pointer_listener,
+					  input);
+
+	locked_pointer =
+		_wl_pointer_lock_lock_pointer(pointer_lock,
+					      window->main_surface->surface,
+					      input->seat,
+					      NULL);
+	_wl_locked_pointer_add_listener(locked_pointer,
+					&locked_pointer_listener,
+					input);
+
+	window->locked_input = input;
+	window->locked_pointer = locked_pointer;
+	window->relative_pointer = relative_pointer;
+
+	return 0;
+}
+
+void
+window_unlock_pointer(struct window *window)
+{
+	if (!window->locked_pointer)
+		return;
+
+	_wl_locked_pointer_destroy(window->locked_pointer);
+	_wl_relative_pointer_release(window->relative_pointer);
+	window->locked_pointer = NULL;
+	window->relative_pointer = NULL;
+	window->pointer_locked = false;
+	window->locked_input = NULL;
+}
+
+void
+widget_set_locked_pointer_cursor_hint(struct widget *widget,
+				      float x, float y)
+{
+	struct window *window = widget->window;
+
+	if (!window->locked_pointer)
+		return;
+
+	_wl_locked_pointer_set_cursor_position_hint(window->locked_pointer,
+						    window->display->serial,
+						    wl_fixed_from_double(x),
+						    wl_fixed_from_double(y));
+}
+
+static void
+confined_pointer_confined(void *data,
+			  struct _wl_confined_pointer *confined_pointer,
+			  uint32_t serial)
+{
+	struct input *input = data;
+	struct window *window = input->pointer_focus;
+
+	if (window->pointer_confined_handler) {
+		window->pointer_confined_handler(window,
+						 input,
+						 window->user_data);
+	}
+}
+
+static void
+confined_pointer_unconfined(void *data,
+			    struct _wl_confined_pointer *confined_pointer)
+{
+	struct input *input = data;
+	struct window *window = input->pointer_focus;
+
+	window_unconfine_pointer(window);
+
+	if (window->pointer_unconfined_handler) {
+		window->pointer_unconfined_handler(window,
+						   input,
+						   window->user_data);
+	}
+}
+
+static const struct _wl_confined_pointer_listener confined_pointer_listener = {
+	confined_pointer_confined,
+	confined_pointer_unconfined,
+};
+
+int
+window_confine_pointer(struct window *window,
+		       struct widget *widget,
+		       struct input *input)
+{
+	struct _wl_pointer_lock *pointer_lock = window->display->pointer_lock;
+	struct _wl_confined_pointer *confined_pointer;
+	struct wl_compositor *compositor = window->display->compositor;
+	struct wl_region *region = NULL;
+
+	if (!window->display->pointer_lock)
+		return -1;
+
+	if (window->locked_pointer)
+		return -1;
+
+	if (window->confined_pointer)
+		return -1;
+
+	if (!input->pointer)
+		return -1;
+
+	if (widget) {
+		region = wl_compositor_create_region(compositor);
+		wl_region_add(region,
+			      widget->allocation.x,
+			      widget->allocation.y,
+			      widget->allocation.width,
+			      widget->allocation.height);
+	}
+
+	confined_pointer =
+		_wl_pointer_lock_confine_pointer(pointer_lock,
+						 window->main_surface->surface,
+						 input->seat,
+						 region);
+	if (region)
+		wl_region_destroy(region);
+
+	_wl_confined_pointer_add_listener(confined_pointer,
+					  &confined_pointer_listener,
+					  input);
+
+	window->confined_pointer = confined_pointer;
+
+	return 0;
+}
+
+void
+window_unconfine_pointer(struct window *window)
+{
+	if (!window->confined_pointer)
+		return;
+
+	_wl_confined_pointer_destroy(window->confined_pointer);
+	window->confined_pointer = NULL;
+}
+
+static void
 surface_enter(void *data,
 	      struct wl_surface *wl_surface, struct wl_output *wl_output)
 {
@@ -5273,6 +5558,15 @@
 	} else if (strcmp(interface, "wl_seat") == 0) {
 		d->seat_version = version;
 		display_add_input(d, id);
+	} else if (strcmp(interface, "_wl_relative_pointer_manager") == 0) {
+		d->relative_pointer_manager =
+			wl_registry_bind(registry, id,
+					 &_wl_relative_pointer_manager_interface,
+					 1);
+	} else if (strcmp(interface, "_wl_pointer_lock") == 0) {
+		d->pointer_lock = wl_registry_bind(registry, id,
+						   &_wl_pointer_lock_interface,
+						   1);
 	} else if (strcmp(interface, "wl_shm") == 0) {
 		d->shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
 		wl_shm_add_listener(d->shm, &shm_listener, d);
--- a/clients/window.h	2015-01-16 17:26:57.000000000 +0100
+++ b/clients/window.h	2015-01-16 18:04:36.778958633 +0100
@@ -222,6 +222,29 @@
 typedef void (*window_state_changed_handler_t)(struct window *window,
 					       void *data);
 
+
+typedef void (*window_locked_pointer_motion_handler_t)(struct window *window,
+						       struct input *input,
+						       uint32_t time,
+						       float x, float y,
+						       void *data);
+
+typedef void (*locked_pointer_locked_handler_t)(struct window *window,
+						struct input *input,
+						void *data);
+
+typedef void (*locked_pointer_unlocked_handler_t)(struct window *window,
+						  struct input *input,
+						  void *data);
+
+typedef void (*confined_pointer_confined_handler_t)(struct window *window,
+						    struct input *input,
+						    void *data);
+
+typedef void (*confined_pointer_unconfined_handler_t)(struct window *window,
+						      struct input *input,
+						      void *data);
+
 typedef void (*widget_resize_handler_t)(struct widget *widget,
 					int32_t width, int32_t height,
 					void *data);
@@ -351,6 +374,24 @@
 window_damage(struct window *window, int32_t x, int32_t y,
 	      int32_t width, int32_t height);
 
+int
+window_lock_pointer(struct window *window, struct input *input);
+
+void
+window_unlock_pointer(struct window *window);
+
+void
+widget_set_locked_pointer_cursor_hint(struct widget *widget,
+				      float x, float y);
+
+int
+window_confine_pointer(struct window *window,
+		       struct widget *widget,
+		       struct input *input);
+
+void
+window_unconfine_pointer(struct window *window);
+
 cairo_surface_t *
 window_get_surface(struct window *window);
 
@@ -429,6 +470,27 @@
 				 window_state_changed_handler_t handler);
 
 void
+window_set_pointer_locked_handler(struct window *window,
+				  locked_pointer_locked_handler_t locked);
+
+void
+window_set_pointer_unlocked_handler(struct window *window,
+				    locked_pointer_unlocked_handler_t unlocked);
+
+void
+window_set_pointer_confined_handler(
+	struct window *window, confined_pointer_confined_handler_t confined);
+
+void
+window_set_pointer_unconfined_handler(
+	struct window *window,
+	confined_pointer_unconfined_handler_t unconfined);
+
+void
+window_set_locked_pointer_motion_handler(
+	struct window *window, window_locked_pointer_motion_handler_t handler);
+
+void
 window_set_title(struct window *window, const char *title);
 
 const char *
--- a/desktop-shell/exposay.c	2015-01-16 17:26:57.000000000 +0100
+++ b/desktop-shell/exposay.c	2015-01-16 18:04:36.757958296 +0100
@@ -160,7 +160,8 @@
 	shell->exposay.column_current = esurface->column;
 	shell->exposay.cur_output = esurface->eoutput;
 
-	activate(shell, view->surface, shell->exposay.seat, false);
+	activate(shell, view, shell->exposay.seat,
+		 WESTON_ACTIVATE_FLAG_NONE);
 	shell->exposay.focus_current = view;
 }
 
@@ -340,12 +341,12 @@
 
 static void
 exposay_motion(struct weston_pointer_grab *grab, uint32_t time,
-	       wl_fixed_t x, wl_fixed_t y)
+	       struct weston_pointer_motion_event *event)
 {
 	struct desktop_shell *shell =
 		container_of(grab, struct desktop_shell, exposay.grab_ptr);
 
-	weston_pointer_move(grab->pointer, x, y);
+	weston_pointer_move(grab->pointer, event);
 
 	exposay_pick(shell,
 	             wl_fixed_to_int(grab->pointer->x),
@@ -378,6 +379,12 @@
 }
 
 static void
+exposay_axis(struct weston_pointer_grab *grab,
+	     uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void
 exposay_pointer_grab_cancel(struct weston_pointer_grab *grab)
 {
 	struct desktop_shell *shell =
@@ -390,6 +397,7 @@
 	exposay_focus,
 	exposay_motion,
 	exposay_button,
+	exposay_axis,
 	exposay_pointer_grab_cancel,
 };
 
@@ -537,11 +545,13 @@
 	 * animating back the old state and then immediately transitioning
 	 * to the new. */
 	if (switch_focus && shell->exposay.focus_current)
-		activate(shell, shell->exposay.focus_current->surface,
-		         shell->exposay.seat, true);
+		activate(shell, shell->exposay.focus_current,
+		         shell->exposay.seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 	else if (shell->exposay.focus_prev)
-		activate(shell, shell->exposay.focus_prev->surface,
-		         shell->exposay.seat, true);
+		activate(shell, shell->exposay.focus_prev,
+		         shell->exposay.seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 
 	wl_list_for_each(esurface, &shell->exposay.surface_list, link)
 		exposay_animate_out(esurface);
--- a/desktop-shell/shell.c	2015-01-16 17:26:57.000000000 +0100
+++ b/desktop-shell/shell.c	2015-01-16 18:04:36.767958457 +0100
@@ -779,7 +779,8 @@
 						 struct focus_state,
 						 surface_destroy_listener);
 	struct desktop_shell *shell;
-	struct weston_surface *main_surface, *next;
+	struct weston_surface *main_surface;
+	struct weston_view *next;
 	struct weston_view *view;
 
 	main_surface = weston_surface_get_main_surface(state->keyboard_focus);
@@ -792,18 +793,19 @@
 		if (is_focus_view(view))
 			continue;
 
-		next = view->surface;
+		next = view;
 		break;
 	}
 
 	/* if the focus was a sub-surface, activate its main surface */
 	if (main_surface != state->keyboard_focus)
-		next = main_surface;
+		next = get_default_view(main_surface);
 
 	shell = state->seat->compositor->shell_interface.shell;
 	if (next) {
 		state->keyboard_focus = NULL;
-		activate(shell, next, state->seat, true);
+		activate(shell, next, state->seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 	} else {
 		if (shell->focus_animation_type == ANIMATION_DIM_LAYER) {
 			if (state->ws->focus_animation)
@@ -1388,14 +1390,28 @@
 }
 
 static void
+unset_keyboard_focus_for_surface(struct weston_surface *surface)
+{
+	struct weston_compositor *compositor = surface->compositor;
+	struct weston_seat *seat;
+	struct weston_surface *focus;
+
+	wl_list_for_each(seat, &compositor->seat_list, link) {
+		if (!seat->keyboard)
+			continue;
+		focus = weston_surface_get_main_surface(seat->keyboard->focus);
+		if (focus == surface)
+			weston_keyboard_set_focus(seat->keyboard, NULL);
+	}
+}
+
+static void
 move_surface_to_workspace(struct desktop_shell *shell,
                           struct shell_surface *shsurf,
                           uint32_t workspace)
 {
 	struct workspace *from;
 	struct workspace *to;
-	struct weston_seat *seat;
-	struct weston_surface *focus;
 	struct weston_view *view;
 
 	if (workspace == shell->workspaces.current)
@@ -1419,14 +1435,7 @@
 	shell_surface_update_child_surface_layers(shsurf);
 
 	drop_focus_state(shell, from, view->surface);
-	wl_list_for_each(seat, &shell->compositor->seat_list, link) {
-		if (!seat->keyboard)
-			continue;
-
-		focus = weston_surface_get_main_surface(seat->keyboard->focus);
-		if (focus == view->surface)
-			weston_keyboard_set_focus(seat->keyboard, NULL);
-	}
+	unset_keyboard_focus_for_surface(view->surface);
 
 	weston_view_damage_below(view);
 }
@@ -1653,6 +1662,12 @@
 }
 
 static void
+noop_grab_axis(struct weston_pointer_grab *grab,
+	       uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void
 constrain_position(struct weston_move_grab *move, int *cx, int *cy)
 {
 	struct shell_surface *shsurf = move->base.shsurf;
@@ -1683,14 +1698,14 @@
 
 static void
 move_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-		 wl_fixed_t x, wl_fixed_t y)
+		 struct weston_pointer_motion_event *event)
 {
 	struct weston_move_grab *move = (struct weston_move_grab *) grab;
 	struct weston_pointer *pointer = grab->pointer;
 	struct shell_surface *shsurf = move->base.shsurf;
 	int cx, cy;
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 	if (!shsurf)
 		return;
 
@@ -1731,6 +1746,7 @@
 	noop_grab_focus,
 	move_grab_motion,
 	move_grab_button,
+	noop_grab_axis,
 	move_grab_cancel,
 };
 
@@ -1804,7 +1820,7 @@
 
 static void
 resize_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-		   wl_fixed_t x, wl_fixed_t y)
+		   struct weston_pointer_motion_event *event)
 {
 	struct weston_resize_grab *resize = (struct weston_resize_grab *) grab;
 	struct weston_pointer *pointer = grab->pointer;
@@ -1813,7 +1829,7 @@
 	wl_fixed_t from_x, from_y;
 	wl_fixed_t to_x, to_y;
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 
 	if (!shsurf)
 		return;
@@ -1886,6 +1902,7 @@
 	noop_grab_focus,
 	resize_grab_motion,
 	resize_grab_button,
+	noop_grab_axis,
 	resize_grab_cancel,
 };
 
@@ -2013,9 +2030,9 @@
 
 static void
 busy_cursor_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-			wl_fixed_t x, wl_fixed_t y)
+			struct weston_pointer_motion_event *event)
 {
-	weston_pointer_move(grab->pointer, x, y);
+	weston_pointer_move(grab->pointer, event);
 }
 
 static void
@@ -2027,10 +2044,12 @@
 	struct weston_seat *seat = grab->grab.pointer->seat;
 
 	if (shsurf && button == BTN_LEFT && state) {
-		activate(shsurf->shell, shsurf->surface, seat, true);
+		activate(shsurf->shell, shsurf->view, seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 		surface_move(shsurf, seat, 0);
 	} else if (shsurf && button == BTN_RIGHT && state) {
-		activate(shsurf->shell, shsurf->surface, seat, true);
+		activate(shsurf->shell, shsurf->view, seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 		surface_rotate(shsurf, seat);
 	}
 }
@@ -2048,6 +2067,7 @@
 	busy_cursor_grab_focus,
 	busy_cursor_grab_motion,
 	busy_cursor_grab_button,
+	noop_grab_axis,
 	busy_cursor_grab_cancel,
 };
 
@@ -2637,44 +2657,41 @@
 }
 
 static void
-set_minimized(struct weston_surface *surface, uint32_t is_true)
+set_minimized(struct weston_surface *surface, bool minimized)
 {
+	struct desktop_shell *shell;
 	struct shell_surface *shsurf;
 	struct workspace *current_ws;
 	struct weston_seat *seat;
-	struct weston_surface *focus;
 	struct weston_view *view;
 
 	view = get_default_view(surface);
 	if (!view)
 		return;
 
-	assert(weston_surface_get_main_surface(view->surface) == view->surface);
+	assert(weston_surface_get_main_surface(view->surface) ==
+	       view->surface);
 
 	shsurf = get_shell_surface(surface);
-	current_ws = get_current_workspace(shsurf->shell);
+	shell = shsurf->shell;
+	current_ws = get_current_workspace(shell);
 
 	weston_layer_entry_remove(&view->layer_link);
-	 /* hide or show, depending on the state */
-	if (is_true) {
-		weston_layer_entry_insert(&shsurf->shell->minimized_layer.view_list, &view->layer_link);
 
-		drop_focus_state(shsurf->shell, current_ws, view->surface);
-		wl_list_for_each(seat, &shsurf->shell->compositor->seat_list, link) {
-			if (!seat->keyboard)
-				continue;
-			focus = weston_surface_get_main_surface(seat->keyboard->focus);
-			if (focus == view->surface)
-				weston_keyboard_set_focus(seat->keyboard, NULL);
-		}
-	}
-	else {
-		weston_layer_entry_insert(&current_ws->layer.view_list, &view->layer_link);
+	if (minimized) {
+		weston_layer_entry_insert(&shell->minimized_layer.view_list,
+					  &view->layer_link);
+		drop_focus_state(shell, current_ws, view->surface);
+		unset_keyboard_focus_for_surface(view->surface);
+	} else {
+		weston_layer_entry_insert(&current_ws->layer.view_list,
+					  &view->layer_link);
 
-		wl_list_for_each(seat, &shsurf->shell->compositor->seat_list, link) {
+		wl_list_for_each(seat, &shell->compositor->seat_list, link) {
 			if (!seat->keyboard)
 				continue;
-			activate(shsurf->shell, view->surface, seat, true);
+			activate(shsurf->shell, view, seat,
+				 WESTON_ACTIVATE_FLAG_CONFIGURE);
 		}
 	}
 
@@ -2833,7 +2850,7 @@
 	}
 
 	surface->configure = black_surface_configure;
-	surface->configure_private = fs_surface;
+	surface->configure_private = view;
 	weston_surface_set_label_func(surface, black_surface_get_label);
 	weston_surface_set_color(surface, 0.0, 0.0, 0.0, 1);
 	pixman_region32_fini(&surface->opaque);
@@ -3128,18 +3145,20 @@
 
 static void
 popup_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-		  wl_fixed_t x, wl_fixed_t y)
+		  struct weston_pointer_motion_event *event)
 {
 	struct weston_pointer *pointer = grab->pointer;
 	struct wl_resource *resource;
+	wl_fixed_t x, y;
 	wl_fixed_t sx, sy;
 
 	if (pointer->focus) {
+		weston_pointer_motion_to_abs(pointer, event, &x, &y);
 		weston_view_from_global_fixed(pointer->focus, x, y,
 					      &pointer->sx, &pointer->sy);
 	}
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 
 	wl_resource_for_each(resource, &pointer->focus_resource_list) {
 		weston_view_from_global_fixed(pointer->focus,
@@ -3179,6 +3198,19 @@
 }
 
 static void
+popup_grab_axis(struct weston_pointer_grab *grab,
+		uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	struct weston_pointer *pointer = grab->pointer;
+	struct wl_resource *resource;
+	struct wl_list *resource_list;
+
+	resource_list = &pointer->focus_resource_list;
+	wl_resource_for_each(resource, resource_list)
+		wl_pointer_send_axis(resource, time, axis, value);
+}
+
+static void
 popup_grab_cancel(struct weston_pointer_grab *grab)
 {
 	popup_grab_end(grab->pointer);
@@ -3188,6 +3220,7 @@
 	popup_grab_focus,
 	popup_grab_motion,
 	popup_grab_button,
+	popup_grab_axis,
 	popup_grab_cancel,
 };
 
@@ -3857,7 +3890,7 @@
 		return;
 
 	 /* apply compositor's own minimization logic (hide) */
-	set_minimized(shsurf->surface, 1);
+	set_minimized(shsurf->surface, true);
 }
 
 static const struct xdg_surface_interface xdg_surface_implementation = {
@@ -4729,7 +4762,7 @@
 
 static void
 rotate_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-		   wl_fixed_t x, wl_fixed_t y)
+		   struct weston_pointer_motion_event *event)
 {
 	struct rotate_grab *rotate =
 		container_of(grab, struct rotate_grab, base.grab);
@@ -4737,7 +4770,7 @@
 	struct shell_surface *shsurf = rotate->base.shsurf;
 	float cx, cy, dx, dy, cposx, cposy, dposx, dposy, r;
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 
 	if (!shsurf)
 		return;
@@ -4826,6 +4859,7 @@
 	noop_grab_focus,
 	rotate_grab_motion,
 	rotate_grab_button,
+	noop_grab_axis,
 	rotate_grab_cancel,
 };
 
@@ -4934,9 +4968,10 @@
 }
 
 void
-activate(struct desktop_shell *shell, struct weston_surface *es,
-	 struct weston_seat *seat, bool configure)
+activate(struct desktop_shell *shell, struct weston_view *view,
+	 struct weston_seat *seat, uint32_t flags)
 {
+	struct weston_surface *es = view->surface;
 	struct weston_surface *main_surface;
 	struct focus_state *state;
 	struct workspace *ws;
@@ -4947,7 +4982,7 @@
 
 	main_surface = weston_surface_get_main_surface(es);
 
-	weston_surface_activate(es, seat);
+	weston_view_activate(view, seat, flags);
 
 	state = ensure_focus_state(shell, seat);
 	if (state == NULL)
@@ -4959,7 +4994,8 @@
 	shsurf = get_shell_surface(main_surface);
 	assert(shsurf);
 
-	if (shsurf->state.fullscreen && configure)
+	if (shsurf->state.fullscreen &&
+	    flags & WESTON_ACTIVATE_FLAG_CONFIGURE)
 		shell_configure_fullscreen(shsurf);
 	else
 		restore_all_output_modes(shell->compositor);
@@ -4981,11 +5017,13 @@
 }
 
 static bool
-is_black_surface (struct weston_surface *es, struct weston_surface **fs_surface)
+is_black_surface(struct weston_view *view, struct weston_view **fs_view)
 {
+	struct weston_surface *es = view->surface;
+
 	if (es->configure == black_surface_configure) {
-		if (fs_surface)
-			*fs_surface = (struct weston_surface *)es->configure_private;
+		if (fs_view)
+			*fs_view = (struct weston_view *) es->configure_private;
 		return true;
 	}
 	return false;
@@ -4994,25 +5032,28 @@
 static void
 activate_binding(struct weston_seat *seat,
 		 struct desktop_shell *shell,
-		 struct weston_surface *focus)
+		 struct weston_view *focus_view,
+		 uint32_t flags)
 {
+	struct weston_view *main_view;
 	struct weston_surface *main_surface;
 
-	if (!focus)
+	if (!focus_view)
 		return;
 
-	if (is_black_surface(focus, &main_surface))
-		focus = main_surface;
+	if (is_black_surface(focus_view, &main_view))
+		focus_view = main_view;
 
-	main_surface = weston_surface_get_main_surface(focus);
+	main_surface = weston_surface_get_main_surface(focus_view->surface);
 	if (get_shell_surface_type(main_surface) == SHELL_SURFACE_NONE)
 		return;
 
-	activate(shell, focus, seat, true);
+	activate(shell, focus_view, seat, true);
 }
 
 static void
-click_to_activate_binding(struct weston_seat *seat, uint32_t time, uint32_t button,
+click_to_activate_binding(struct weston_seat *seat,
+			  uint32_t time, uint32_t button,
 			  void *data)
 {
 	if (seat->pointer->grab != &seat->pointer->default_grab)
@@ -5020,7 +5061,9 @@
 	if (seat->pointer->focus == NULL)
 		return;
 
-	activate_binding(seat, data, seat->pointer->focus->surface);
+	activate_binding(seat, data, seat->pointer->focus,
+			 WESTON_ACTIVATE_FLAG_CLICKED |
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 }
 
 static void
@@ -5031,7 +5074,8 @@
 	if (seat->touch->focus == NULL)
 		return;
 
-	activate_binding(seat, data, seat->touch->focus->surface);
+	activate_binding(seat, data, seat->touch->focus,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
 }
 
 static void
@@ -5439,7 +5483,8 @@
 		if (shell->locked)
 			break;
 		wl_list_for_each(seat, &compositor->seat_list, link)
-			activate(shell, shsurf->surface, seat, true);
+			activate(shell, shsurf->view, seat,
+				 WESTON_ACTIVATE_FLAG_CONFIGURE);
 		break;
 	case SHELL_SURFACE_POPUP:
 	case SHELL_SURFACE_NONE:
@@ -5846,7 +5891,7 @@
 
 struct switcher {
 	struct desktop_shell *shell;
-	struct weston_surface *current;
+	struct weston_view *current;
 	struct wl_listener listener;
 	struct weston_keyboard_grab grab;
 	struct wl_array minimized_array;
@@ -5856,7 +5901,7 @@
 switcher_next(struct switcher *switcher)
 {
 	struct weston_view *view;
-	struct weston_surface *first = NULL, *prev = NULL, *next = NULL;
+	struct weston_view *first = NULL, *prev = NULL, *next = NULL;
 	struct shell_surface *shsurf;
 	struct workspace *ws = get_current_workspace(switcher->shell);
 
@@ -5876,16 +5921,16 @@
 		    shsurf->type == SHELL_SURFACE_TOPLEVEL &&
 		    shsurf->parent == NULL) {
 			if (first == NULL)
-				first = view->surface;
+				first = view;
 			if (prev == switcher->current)
-				next = view->surface;
-			prev = view->surface;
+				next = view;
+			prev = view;
 			view->alpha = 0.25;
 			weston_view_geometry_dirty(view);
 			weston_surface_damage(view->surface);
 		}
 
-		if (is_black_surface(view->surface, NULL)) {
+		if (is_black_surface(view, NULL)) {
 			view->alpha = 0.25;
 			weston_view_geometry_dirty(view);
 			weston_surface_damage(view->surface);
@@ -5902,10 +5947,10 @@
 	wl_signal_add(&next->destroy_signal, &switcher->listener);
 
 	switcher->current = next;
-	wl_list_for_each(view, &next->views, surface_link)
+	wl_list_for_each(view, &next->surface->views, surface_link)
 		view->alpha = 1.0;
 
-	shsurf = get_shell_surface(switcher->current);
+	shsurf = get_shell_surface(switcher->current->surface);
 	if (shsurf && shsurf->state.fullscreen)
 		shsurf->fullscreen.black_view->alpha = 1.0;
 }
@@ -5934,9 +5979,12 @@
 		weston_surface_damage(view->surface);
 	}
 
-	if (switcher->current)
+	if (switcher->current) {
 		activate(switcher->shell, switcher->current,
-			 (struct weston_seat *) keyboard->seat, true);
+			 (struct weston_seat *) keyboard->seat,
+			 WESTON_ACTIVATE_FLAG_CONFIGURE);
+	}
+
 	wl_list_remove(&switcher->listener.link);
 	weston_keyboard_end_grab(keyboard);
 	if (keyboard->input_method_resource)
@@ -5946,7 +5994,7 @@
 	struct weston_view **minimized;
 	wl_array_for_each(minimized, &switcher->minimized_array) {
 		/* with the exception of the current selected */
-		if ((*minimized)->surface != switcher->current) {
+		if ((*minimized)->surface != switcher->current->surface) {
 			weston_layer_entry_remove(&(*minimized)->layer_link);
 			weston_layer_entry_insert(&switcher->shell->minimized_layer.view_list, &(*minimized)->layer_link);
 			weston_view_damage_below(*minimized);
--- a/desktop-shell/shell.h	2015-01-16 17:26:57.000000000 +0100
+++ b/desktop-shell/shell.h	2015-01-16 18:04:36.758958312 +0100
@@ -230,8 +230,8 @@
 lower_fullscreen_layer(struct desktop_shell *shell);
 
 void
-activate(struct desktop_shell *shell, struct weston_surface *es,
-	 struct weston_seat *seat, bool configure);
+activate(struct desktop_shell *shell, struct weston_view *view,
+	 struct weston_seat *seat, uint32_t flags);
 
 void
 exposay_binding(struct weston_seat *seat,
--- a/Makefile.am	2015-01-16 17:26:57.000000000 +0100
+++ b/Makefile.am	2015-01-16 18:04:36.777958617 +0100
@@ -91,7 +91,11 @@
 	protocol/presentation_timing-protocol.c		\
 	protocol/presentation_timing-server-protocol.h	\
 	protocol/scaler-protocol.c			\
-	protocol/scaler-server-protocol.h
+	protocol/scaler-server-protocol.h		\
+	protocol/pointer-lock-protocol.c		\
+	protocol/pointer-lock-server-protocol.h		\
+	protocol/relative-pointer-protocol.c		\
+	protocol/relative-pointer-server-protocol.h
 
 BUILT_SOURCES += $(nodist_weston_SOURCES)
 
@@ -467,7 +471,11 @@
 	protocol/xdg-shell-protocol.c			\
 	protocol/xdg-shell-client-protocol.h		\
 	protocol/ivi-application-protocol.c		\
-	protocol/ivi-application-client-protocol.h
+	protocol/ivi-application-client-protocol.h	\
+	protocol/pointer-lock-protocol.c		\
+	protocol/pointer-lock-client-protocol.h		\
+	protocol/relative-pointer-protocol.c		\
+	protocol/relative-pointer-client-protocol.h
 
 BUILT_SOURCES += $(nodist_libtoytoolkit_la_SOURCES)
 
@@ -1093,7 +1101,9 @@
 	protocol/presentation_timing.xml	\
 	protocol/scaler.xml			\
 	protocol/ivi-application.xml		\
-	protocol/ivi-hmi-controller.xml
+	protocol/ivi-hmi-controller.xml		\
+	protocol/pointer-lock.xml		\
+	protocol/relative-pointer.xml
 
 man_MANS = weston.1 weston.ini.5
 
--- a/protocol/input-method.xml	2015-01-16 17:26:57.000000000 +0100
+++ b/protocol/input-method.xml	2015-01-16 18:04:36.738957992 +0100
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <protocol name="input_method">
+
   <copyright>
     Copyright © 2012, 2013 Intel Corporation
 
@@ -25,7 +26,6 @@
     THIS SOFTWARE.
   </copyright>
 
-
   <interface name="wl_input_method_context" version="1">
     <description summary="input method context">
       Corresponds to a text model on input method side. An input method context
@@ -43,7 +43,9 @@
       and keysym. The text input can then ignore events from the input method
       which are based on an outdated state (for example after a reset).
     </description>
+
     <request name="destroy" type="destructor"/>
+
     <request name="commit_string">
       <description summary="commit string">
         Send the commit string text for insertion to the application.
@@ -59,6 +61,7 @@
       <arg name="serial" type="uint" summary="serial of the latest known text input state"/>
       <arg name="text" type="string"/>
     </request>
+
     <request name="preedit_string">
       <description summary="pre-edit string">
         Send the pre-edit string text to the application text input.
@@ -73,6 +76,7 @@
       <arg name="text" type="string"/>
       <arg name="commit" type="string"/>
     </request>
+
     <request name="preedit_styling">
       <description summary="pre-edit styling">
         Sets styling information on composing text. The style is applied for
@@ -86,6 +90,7 @@
       <arg name="length" type="uint"/>
       <arg name="style" type="uint"/>
     </request>
+
     <request name="preedit_cursor">
       <description summary="pre-edit cursor">
         Sets the cursor position inside the composing text (as byte offset)
@@ -97,16 +102,16 @@
       </description>
       <arg name="index" type="int"/>
     </request>
+
     <request name="delete_surrounding_text">
       <description summary="delete text">
-
-
         This request will be handled on text_input side as part of a directly
         following commit_string request.
       </description>
       <arg name="index" type="int"/>
       <arg name="length" type="uint"/>
     </request>
+
     <request name="cursor_position">
       <description summary="set cursor to a new position">
         Sets the cursor and anchor to a new position. Index is the new cursor
@@ -122,9 +127,11 @@
       <arg name="index" type="int"/>
       <arg name="anchor" type="int"/>
     </request>
+
     <request name="modifiers_map">
       <arg name="map" type="array"/>
     </request>
+
     <request name="keysym">
       <description summary="keysym">
         Notify when a key event was sent. Key events should not be used for
@@ -138,6 +145,7 @@
       <arg name="state" type="uint"/>
       <arg name="modifiers" type="uint"/>
     </request>
+
     <request name="grab_keyboard">
       <description summary="grab hardware keyboard">
         Allows an input method to receive hardware keyboard input and process
@@ -145,8 +153,9 @@
         allows input methods which compose multiple key events for inputting
         text like it is done for CJK languages.
       </description>
-       <arg name="keyboard" type="new_id" interface="wl_keyboard"/>
+      <arg name="keyboard" type="new_id" interface="wl_keyboard"/>
     </request>
+
     <request name="key">
       <description summary="forward key event">
         Should be used when filtering key events with grab_keyboard.
@@ -163,6 +172,7 @@
       <arg name="key" type="uint" summary="key from wl_keyboard::key"/>
       <arg name="state" type="uint" summary="state from wl_keyboard::key"/>
     </request>
+
     <request name="modifiers">
       <description summary="forward modifiers event">
         Should be used when filtering key events with grab_keyboard.
@@ -177,6 +187,7 @@
       <arg name="mods_locked" type="uint" summary="mods_locked from wl_keyboard::modifiers"/>
       <arg name="group" type="uint" summary="group from wl_keyboard::modifiers"/>
     </request>
+
     <request name="language">
       <arg name="serial" type="uint" summary="serial of the latest known text input state"/>
       <arg name="language" type="string"/>
@@ -185,6 +196,7 @@
       <arg name="serial" type="uint" summary="serial of the latest known text input state"/>
       <arg name="direction" type="uint"/>
     </request>
+
     <event name="surrounding_text">
       <description summary="surrounding text event">
         The plain surrounding text around the input position. Cursor is the
@@ -197,19 +209,24 @@
       <arg name="cursor" type="uint"/>
       <arg name="anchor" type="uint"/>
     </event>
+
     <event name="reset">
     </event>
+
     <event name="content_type">
       <arg name="hint" type="uint"/>
       <arg name="purpose" type="uint"/>
     </event>
+
     <event name="invoke_action">
       <arg name="button" type="uint"/>
       <arg name="index" type="uint"/>
     </event>
+
     <event name="commit_state">
       <arg name="serial" type="uint" summary="serial of text input state"/>
     </event>
+
     <event name="preferred_language">
       <arg name="language" type="string"/>
     </event>
@@ -222,6 +239,7 @@
       object per seat. On activate there is a new input method context object
       created which allows the input method to communicate with the text model.
     </description>
+
     <event name="activate">
       <description summary="activate event">
         A text model was activated. Creates an input method context object
@@ -229,6 +247,7 @@
       </description>
       <arg name="id" type="new_id" interface="wl_input_method_context"/>
     </event>
+
     <event name="deactivate">
       <description summary="activate event">
         The text model corresponding to the context argument was deactivated.
@@ -270,4 +289,5 @@
       </description>
     </request>
   </interface>
+
 </protocol>
--- a/protocol/pointer-lock.xml	1970-01-01 01:00:00.000000000 +0100
+++ b/protocol/pointer-lock.xml	2015-01-16 18:04:36.774958569 +0100
@@ -0,0 +1,208 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="pointer_lock">
+
+  <copyright>
+    Copyright © 2014      Jonas Ådahl
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <interface name="_wl_pointer_lock" version="1">
+    <description summary="lock pointer to a surface">
+      The global interface exposing pointer locking functionality. It exposes
+      two requests; lock_pointer for locking the pointer to its position, and
+      confine_pointer for locking the pointer to a region.
+
+      The lock_pointer and confine_pointer creates the objects wl_locked_pointer
+      and wl_confined_pointer respectively, and the client can use these objects
+      to interact with the lock.
+
+      There may not be another lock of any kind active when requesting a lock,
+      and if there is, an error will be raised.
+    </description>
+
+    <request name="lock_pointer">
+      <description summary="lock pointer to a position">
+        The lock_pointer request lets the client disable absolute pointer
+        movements, locking the pointer to a position.
+
+        There may not be another lock of any kind active when requesting a lock,
+        and if there is, an error will be raised.
+
+        The intersection of the region passed with this request and the input
+        region of the surface is used to determine where the pointer must be
+        in order for the lock to activate. It is up to the compositor to warp
+        the pointer, or require some kind of user interaction for the lock to
+        activate. If the region is null, then an infinit region is used.
+
+        The request will create a new object wl_locked_pointer which is used to
+        interact with the lock as well as receive updates about its state. See
+        the the description of wl_locked_pointer for further information.
+
+        Note that while a locked pointer doesn't move its absolute position, it
+        may still emit relative motion events via the wl_relative_pointer
+        object.
+      </description>
+
+      <arg name="id" type="new_id" interface="_wl_locked_pointer"/>
+      <arg name="surface" type="object" interface="wl_surface"
+           summary="surface to lock pointer to"/>
+      <arg name="seat" type="object" interface="wl_seat"
+           summary="seat where the pointer should be locked"/>
+      <arg name="region" type="object" interface="wl_region" allow-null="true"
+           summary="region of surface"/>
+    </request>
+
+    <request name="confine_pointer">
+      <description summary="confine pointer to a region">
+        The confine_pointer request lets the client confine the pointer cursor
+        to a given region.
+
+        The intersection of the region passed with this request and the input
+        region of the surface is used to determine where the pointer must be
+        in order for the confinement to activate. It is up to the compositor to
+        warp the pointer, or require some kind of user interaction for the
+        confinement to activate. If the region is null, then an infinite region
+        is used.
+
+        The request will create a new object wl_confined_pointer which is used
+        to interact with the confinement as well as receive updates about its
+        state. See the the description of wl_confined_pointer for further
+        information.
+      </description>
+
+      <arg name="id" type="new_id" interface="_wl_confined_pointer"/>
+      <arg name="surface" type="object" interface="wl_surface"
+           summary="surface to lock pointer to"/>
+      <arg name="seat" type="object" interface="wl_seat"
+           summary="seat where the pointer should be locked"/>
+      <arg name="region" type="object" interface="wl_region" allow-null="true"
+           summary="region of surface"/>
+    </request>
+
+  </interface>
+
+  <interface name="_wl_locked_pointer" version="1">
+    <description summary="receive relative pointer motion events">
+      The wl_locked_pointer interface represents a locked pointer state.
+
+      While the lock of this object is active, the pointer of the associated
+      seat will not move.
+
+      This object will send the event 'locked' when the lock is activated.
+      Whenever the lock is activated, it is guaranteed that the locked surface
+      will already have received pointer focus and that the pointer will be
+      within the region passed to the request creating this object.
+
+      To unlock the pointer, send the destroy request. This will also destroy
+      the wl_locked_pointer object.
+
+      If the compositor decides to unlock the pointer the unlocked event is sent.
+      The wl_locked_pointer object is at this point defunct and should be
+      destoryed.
+
+      When unlocking, the compositor may or may not take the cursor position
+      hint provided using the set_cursor_position_hint request and warp the
+      pointer. If it does, it will not result in any relative motion events.
+    </description>
+
+    <request name="set_cursor_position_hint">
+      <description summary="set the pointer cursor position hint">
+        Set the cursor position hint relative to the top left corner of the
+        surface.
+      </description>
+
+      <arg name="serial" type="uint" summary="serial of the enter event"/>
+      <arg name="surface_x" type="fixed"
+           summary="x coordinate in surface-relative coordinates"/>
+      <arg name="surface_y" type="fixed"
+           summary="y coordinate in surface-relative coordinates"/>
+    </request>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the locked pointer object">
+        Destroy the locked pointer object. The compositor will unlock the
+        pointer.
+      </description>
+    </request>
+
+    <event name="locked">
+      <description summary="enter event">
+        Notification that the pointer lock of this seat's pointer is activated.
+      </description>
+
+      <arg name="serial" type="uint"/>
+    </event>
+
+    <event name="unlocked">
+      <description summary="leave event">
+        Notification that the pointer lock of seat's pointer is no longer
+        active. This object is no defunct and should be destroyed.
+      </description>
+    </event>
+  </interface>
+
+  <interface name="_wl_confined_pointer" version="1">
+    <description summary="confined pointer object">
+      The wl_confined_pointer interface represents a confined pointer state.
+
+      This object will send the event 'confined' when the confinement is
+      activated. Whenever the confinement is activated, it is guaranteed that
+      the surface the pointer is confined to will already have received pointer
+      focus and that the pointer will be within the region passed to the request
+      creating this object. It is up to the compositor to decide whether this
+      requires some user interaction and if the pointer will warp to within the
+      passed region if outside.
+
+      To unconfine the pointer, send the destroy request. This will also destroy
+      the wl_confined_pointer object.
+
+      If the compositor decides to unconfine the pointer the unconfined event is
+      sent. The wl_confined_pointer object is at this point defunct and should
+      be destoryed.
+    </description>
+
+    <request name="destroy" type="destructor">
+      <description summary="destroy the confined pointer object">
+        Destroy the confined pointer object. The compositor will unconfine the
+        pointer.
+      </description>
+    </request>
+
+    <event name="confined">
+      <description summary="enter event">
+        Notification that the pointer confinement of this seat's pointer is
+        activated.
+      </description>
+
+      <arg name="serial" type="uint"/>
+    </event>
+
+    <event name="unconfined">
+      <description summary="leave event">
+        Notification that the pointer confinement of seat's pointer is no
+        longer active. This object is no defunct and should be destroyed.
+      </description>
+    </event>
+  </interface>
+
+</protocol>
--- a/protocol/relative-pointer.xml	1970-01-01 01:00:00.000000000 +0100
+++ b/protocol/relative-pointer.xml	2015-01-16 18:04:36.771958521 +0100
@@ -0,0 +1,90 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="relative_pointer">
+
+  <copyright>
+    Copyright © 2014      Jonas Ådahl
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <interface name="_wl_relative_pointer_manager" version="1">
+    <description summary="get relative pointer objects">
+      A global interface used for getting the relative pointer object for a
+      given seat.
+    </description>
+
+    <request name="get_relative_pointer">
+      <description summary="get a relative pointer object">
+        Create a relative pointer interface for the pointer of the given seat.
+
+        This request only takes effect if the seat has the pointer capability.
+      </description>
+
+      <arg name="id" type="new_id" interface="_wl_relative_pointer"/>
+      <arg name="seat" type="object" interface="wl_seat"/>
+    </request>
+  </interface>
+
+  <interface name="_wl_relative_pointer" version="1">
+    <description summary="relative pointer object">
+      A wl_relative_pointer object is an extension to the wl_pointer interface
+      only used for emitting relative pointer events. It will only emit events
+      when the parent pointer has focus.
+    </description>
+
+    <request name="release" type="destructor">
+      <description summary="release the relative pointer object"/>
+    </request>
+
+    <event name="relative_motion">
+      <description summary="relative pointer motion">
+        Relative pointer motion from the pointer of the seat associated with
+        this object.
+
+        This event contains both the accelerated motion delta and the
+        non-accelerated motion delta. The non-accelerated delta is, when
+        applicable, the regular pointer motion delta as it was before having
+        applied motion acceleration transformations. Note that it does not
+        represent 'raw' events as they were read from some device. What
+        acceleration corresponds to is device specific and may be identical
+        to non-accelerated for some devices, while for others not.
+
+        Relative motions are not coupled to wl_pointer.motion events, and can
+        be sent in combination with such events, but also independently. There
+        may also be scenarious where wl_pointer.motion is sent, but there is no
+        relative motion.
+      </description>
+
+      <arg name="time" type="uint"
+           summary="timestamp with millisecond granularity"/>
+      <arg name="dx" type="fixed"
+           summary="x component of the motion vector"/>
+      <arg name="dy" type="fixed"
+           summary="y component of the motion vector"/>
+      <arg name="dx_noaccel" type="fixed"
+           summary="x component of the nonaccelerated motion vector"/>
+      <arg name="dy_noaccel" type="fixed"
+           summary="y component of the nonaccelerated motion vector"/>
+    </event>
+  </interface>
+
+</protocol>
--- a/protocol/text.xml	2015-01-16 17:26:57.000000000 +0100
+++ b/protocol/text.xml	2015-01-16 18:04:36.738957992 +0100
@@ -48,6 +48,7 @@
       and keysym. The text input can then ignore events from the input method
       which are based on an outdated state (for example after a reset).
     </description>
+
     <request name="activate">
       <description summary="request activation">
         Requests the text-input object to be activated (typically when the 
@@ -60,6 +61,7 @@
       <arg name="seat" type="object" interface="wl_seat"/>
       <arg name="surface" type="object" interface="wl_surface"/>
     </request>
+
     <request name="deactivate">
       <description summary="request deactivation">
         Requests the text-input object to be deactivated (typically when the
@@ -68,16 +70,19 @@
       </description>
       <arg name="seat" type="object" interface="wl_seat"/>
     </request>
+
     <request name="show_input_panel">
       <description summary="show input panels">
         Requests input panels (virtual keyboard) to show.
       </description>
     </request>
+
     <request name="hide_input_panel">
       <description summary="hide input panels">
         Requests input panels (virtual keyboard) to hide.
       </description>
     </request>
+
     <request name="reset">
       <description summary="reset">
         Should be called by an editor widget when the input state should be
@@ -85,6 +90,7 @@
         input method flow.
       </description>
     </request>
+
     <request name="set_surrounding_text">
       <description summary="sets the surrounding text">
         Sets the plain surrounding text around the input position. Text is
@@ -97,6 +103,7 @@
       <arg name="cursor" type="uint"/>
       <arg name="anchor" type="uint"/>
     </request>
+
     <enum name="content_hint">
       <description summary="content hint">
         Content hint is a bitmask to allow to modify the behavior of the text
@@ -116,6 +123,7 @@
       <entry name="latin" value="0x100" summary="just latin characters should be entered"/>
       <entry name="multiline" value="0x200" summary="the text input is multiline"/>
     </enum>
+
     <enum name="content_purpose">
       <description summary="content purpose">
         The content purpose allows to specify the primary purpose of a text
@@ -138,6 +146,7 @@
       <entry name="datetime" value="11" summary="input a date and time"/>
       <entry name="terminal" value="12" summary="input for a terminal"/>
     </enum>
+
     <request name="set_content_type">
       <description summary="set content purpose and hint">
         Sets the content purpose and content hint. While the purpose is the
@@ -151,12 +160,14 @@
       <arg name="hint" type="uint"/>
       <arg name="purpose" type="uint"/>
     </request>
+
     <request name="set_cursor_rectangle">
       <arg name="x" type="int"/>
       <arg name="y" type="int"/>
       <arg name="width" type="int"/>
       <arg name="height" type="int"/>
     </request>
+
     <request name="set_preferred_language">
       <description summary="sets preferred language">
         Sets a specific language. This allows for example a virtual keyboard to
@@ -169,13 +180,16 @@
       </description>
       <arg name="language" type="string"/>
     </request>
+
     <request name="commit_state">
       <arg name="serial" type="uint" summary="used to identify the known state"/>
     </request>
+
     <request name="invoke_action">
       <arg name="button" type="uint"/>
       <arg name="index" type="uint"/>
     </request>
+
     <event name="enter">
       <description summary="enter event">
         Notify the text-input object when it received focus. Typically in
@@ -183,6 +197,7 @@
       </description>
       <arg name="surface" type="object" interface="wl_surface"/>
     </event>
+
     <event name="leave">
       <description summary="leave event">
         Notify the text-input object when it lost focus. Either in response
@@ -190,6 +205,7 @@
         destroyed.
       </description>
     </event>
+
     <event name="modifiers_map">
       <description summary="modifiers map">
         Transfer an array of 0-terminated modifiers names. The position in
@@ -198,12 +214,14 @@
       </description>
       <arg name="map" type="array"/>
     </event>
+
     <event name="input_panel_state">
       <description summary="state of the input panel">
         Notify when the visibility state of the input panel changed.
       </description>
       <arg name="state" type="uint"/>
     </event>
+
     <event name="preedit_string">
       <description summary="pre-edit">
         Notify when a new composing text (pre-edit) should be set around the
@@ -220,6 +238,7 @@
       <arg name="text" type="string"/>
       <arg name="commit" type="string"/>
     </event>
+
     <enum name="preedit_style">
       <entry name="default" value="0" summary="default style for composing text"/>
       <entry name="none" value="1" summary="style should be the same as in non-composing text"/>
@@ -230,6 +249,7 @@
       <entry name="selection" value="6"/>
       <entry name="incorrect" value="7"/>
     </enum>
+
     <event name="preedit_styling">
       <description summary="pre-edit styling">
         Sets styling information on composing text. The style is applied for
@@ -244,6 +264,7 @@
       <arg name="length" type="uint"/>
       <arg name="style" type="uint"/>
     </event>
+
     <event name="preedit_cursor">
       <description summary="pre-edit cursor">
         Sets the cursor position inside the composing text (as byte
@@ -254,6 +275,7 @@
       </description>
       <arg name="index" type="int"/>
     </event>
+
     <event name="commit_string">
       <description summary="commit">
         Notify when text should be inserted into the editor widget. The text to
@@ -267,6 +289,7 @@
       <arg name="serial" type="uint" summary="serial of the latest known text input state"/>
       <arg name="text" type="string"/>
     </event>
+
     <event name="cursor_position">
       <description summary="set cursor to new position">
         Notify when the cursor or anchor position should be modified.
@@ -277,6 +300,7 @@
       <arg name="index" type="int"/>
       <arg name="anchor" type="int"/>
     </event>
+
     <event name="delete_surrounding_text">
       <description summary="delete surrounding text">
         Notify when the text around the current cursor position should be
@@ -291,6 +315,7 @@
       <arg name="index" type="int"/>
       <arg name="length" type="uint"/>
     </event>
+
     <event name="keysym">
       <description summary="keysym">
         Notify when a key event was sent. Key events should not be used
@@ -306,6 +331,7 @@
       <arg name="state" type="uint"/>
       <arg name="modifiers" type="uint"/>
     </event>
+
     <event name="language">
       <description summary="language">
         Sets the language of the input text. The "language" argument is a RFC-3066 
@@ -314,11 +340,13 @@
       <arg name="serial" type="uint" summary="serial of the latest known text input state"/>
       <arg name="language" type="string"/>
     </event>
+
     <enum name="text_direction">
       <entry name="auto" value="0" summary="automatic text direction based on text and language"/>
       <entry name="ltr" value="1" summary="left-to-right"/>
       <entry name="rtl" value="2" summary="right-to-left"/>
     </enum>
+
     <event name="text_direction">
       <description summary="text direction">
         Sets the text direction of input text.
@@ -336,6 +364,7 @@
     <description summary="text input manager">
       A factory for text-input objects. This object is a global singleton.
     </description>
+
     <request name="create_text_input">
       <description summary="create text input">
         Creates a new text-input object.
@@ -343,4 +372,5 @@
       <arg name="id" type="new_id" interface="wl_text_input"/>
     </request>
   </interface>
+
 </protocol>
--- a/src/compositor.c	2015-01-16 17:26:57.000000000 +0100
+++ b/src/compositor.c	2015-01-16 18:04:36.775958585 +0100
@@ -635,6 +635,8 @@
 	wl_list_init(&surface->subsurface_list);
 	wl_list_init(&surface->subsurface_list_pending);
 
+	region_init_infinite(&surface->pointer_lock.region);
+
 	return surface;
 }
 
@@ -1649,6 +1651,8 @@
 
 	weston_presentation_feedback_discard_list(&surface->feedback_list);
 
+	pixman_region32_fini(&surface->pointer_lock.region);
+
 	free(surface);
 }
 
@@ -4092,6 +4096,8 @@
 
 	ec->output_id_pool = 0;
 
+	ec->activate_serial = 1;
+
 	if (!wl_global_create(display, &wl_compositor_interface, 3,
 			      ec, compositor_bind))
 		return -1;
@@ -4123,6 +4129,9 @@
 	weston_plane_init(&ec->primary_plane, ec, 0, 0);
 	weston_compositor_stack_plane(ec, &ec->primary_plane, NULL);
 
+	if (weston_input_init(ec) != 0)
+		return -1;
+
 	s = weston_config_get_section(ec->config, "keyboard", NULL, NULL);
 	weston_config_section_get_string(s, "keymap_rules",
 					 (char **) &xkb_names.rules, NULL);
--- a/src/compositor.h	2015-01-16 17:26:57.000000000 +0100
+++ b/src/compositor.h	2015-01-16 18:04:36.775958585 +0100
@@ -239,13 +239,31 @@
 	struct weston_timeline_object timeline;
 };
 
+enum weston_pointer_motion_mask {
+	WESTON_POINTER_MOTION_ABS = 1 << 0,
+	WESTON_POINTER_MOTION_REL = 1 << 1,
+	WESTON_POINTER_MOTION_REL_NOACCEL = 1 << 2,
+};
+
+struct weston_pointer_motion_event {
+	uint32_t mask;
+	wl_fixed_t x;
+	wl_fixed_t y;
+	wl_fixed_t dx;
+	wl_fixed_t dy;
+	wl_fixed_t dx_noaccel;
+	wl_fixed_t dy_noaccel;
+};
+
 struct weston_pointer_grab;
 struct weston_pointer_grab_interface {
 	void (*focus)(struct weston_pointer_grab *grab);
 	void (*motion)(struct weston_pointer_grab *grab, uint32_t time,
-		       wl_fixed_t x, wl_fixed_t y);
+		       struct weston_pointer_motion_event *event);
 	void (*button)(struct weston_pointer_grab *grab,
 		       uint32_t time, uint32_t button, uint32_t state);
+	void (*axis)(struct weston_pointer_grab *grab,
+		     uint32_t time, uint32_t axis, wl_fixed_t value);
 	void (*cancel)(struct weston_pointer_grab *grab);
 };
 
@@ -315,13 +333,16 @@
 	struct weston_seat *seat;
 
 	struct wl_list resource_list;
+	struct wl_list relative_resource_list;
 	struct wl_list focus_resource_list;
+	struct wl_list relative_focus_resource_list;
 	struct weston_view *focus;
 	uint32_t focus_serial;
 	struct wl_listener focus_view_listener;
 	struct wl_listener focus_resource_listener;
 	struct wl_signal focus_signal;
 	struct wl_signal motion_signal;
+	struct wl_signal destroy_signal;
 
 	struct weston_view *sprite;
 	struct wl_listener sprite_destroy_listener;
@@ -363,6 +384,11 @@
 	uint32_t grab_time;
 };
 
+void
+weston_pointer_motion_to_abs(struct weston_pointer *pointer,
+			     struct weston_pointer_motion_event *event,
+			     wl_fixed_t *x, wl_fixed_t *y);
+
 struct weston_pointer *
 weston_pointer_create(struct weston_seat *seat);
 void
@@ -381,7 +407,7 @@
 			    wl_fixed_t *fx, wl_fixed_t *fy);
 void
 weston_pointer_move(struct weston_pointer *pointer,
-		    wl_fixed_t x, wl_fixed_t y);
+		    struct weston_pointer_motion_event *event);
 void
 weston_pointer_set_default_grab(struct weston_pointer *pointer,
 		const struct weston_pointer_grab_interface *interface);
@@ -668,6 +694,10 @@
 	clockid_t presentation_clock;
 
 	int exit_code;
+
+	unsigned int activate_serial;
+
+	struct wl_global *pointer_lock;
 };
 
 struct weston_buffer {
@@ -760,6 +790,8 @@
 	struct weston_plane *plane;
 	struct weston_view *parent_view;
 
+	unsigned int click_to_activate_serial;
+
 	pixman_region32_t clip;
 	float alpha;                     /* part of geometry, see below */
 
@@ -920,6 +952,24 @@
 	const char *role_name;
 
 	struct weston_timeline_object timeline;
+
+	struct {
+		struct weston_view *view;
+		pixman_region32_t region;
+		struct wl_resource *resource;
+		struct weston_pointer_grab grab;
+		struct weston_pointer *pointer;
+
+		bool hint_set;
+		wl_fixed_t x_hint;
+		wl_fixed_t y_hint;
+
+		struct wl_listener pointer_destroy_listener;
+		struct wl_listener surface_destroy_listener;
+
+		struct wl_listener keyboard_focus_listener;
+		struct wl_listener surface_activate_listener;
+	} pointer_lock;
 };
 
 struct weston_subsurface {
@@ -956,6 +1006,12 @@
 	STATE_UPDATE_NONE,
 };
 
+enum weston_activate_flag {
+	WESTON_ACTIVATE_FLAG_NONE = 0,
+	WESTON_ACTIVATE_FLAG_CLICKED = 1 << 0,
+	WESTON_ACTIVATE_FLAG_CONFIGURE = 1 << 1,
+};
+
 void
 weston_version(int *major, int *minor, int *micro);
 
@@ -1005,9 +1061,15 @@
 void
 weston_surface_activate(struct weston_surface *surface,
 			struct weston_seat *seat);
+
+void
+weston_view_activate(struct weston_view *view,
+		     struct weston_seat *seat,
+		     uint32_t flags);
+
 void
 notify_motion(struct weston_seat *seat, uint32_t time,
-	      wl_fixed_t dx, wl_fixed_t dy);
+	      struct weston_pointer_motion_event *event);
 void
 notify_motion_absolute(struct weston_seat *seat, uint32_t time,
 		       wl_fixed_t x, wl_fixed_t y);
@@ -1457,6 +1519,9 @@
 int
 noop_renderer_init(struct weston_compositor *ec);
 
+int
+weston_input_init(struct weston_compositor *compositor);
+
 struct weston_compositor *
 backend_init(struct wl_display *display, int *argc, char *argv[],
 	     struct weston_config *config);
--- a/src/compositor-x11.c	2015-01-16 17:26:57.000000000 +0100
+++ b/src/compositor-x11.c	2015-01-16 18:04:36.743958072 +0100
@@ -1063,12 +1063,13 @@
 
 static void
 x11_compositor_deliver_motion_event(struct x11_compositor *c,
-					xcb_generic_event_t *event)
+				    xcb_generic_event_t *xcb_event)
 {
 	struct x11_output *output;
 	wl_fixed_t x, y;
+	struct weston_pointer_motion_event event = { 0 };
 	xcb_motion_notify_event_t *motion_notify =
-			(xcb_motion_notify_event_t *) event;
+			(xcb_motion_notify_event_t *) xcb_event;
 
 	if (!c->has_xkb)
 		update_xkb_state_from_core(c, motion_notify->state);
@@ -1081,8 +1082,14 @@
 					   wl_fixed_from_int(motion_notify->event_y),
 					   &x, &y);
 
+	event = (struct weston_pointer_motion_event) {
+		.mask = WESTON_POINTER_MOTION_REL,
+		.dx = x - c->prev_x,
+		.dy = y - c->prev_y,
+	};
+
 	notify_motion(&c->core_seat, weston_compositor_get_time(),
-		      x - c->prev_x, y - c->prev_y);
+		      &event);
 
 	c->prev_x = x;
 	c->prev_y = y;
--- a/src/data-device.c	2015-01-16 17:26:57.000000000 +0100
+++ b/src/data-device.c	2015-01-16 18:04:36.744958088 +0100
@@ -330,7 +330,7 @@
 
 static void
 drag_grab_motion(struct weston_pointer_grab *grab, uint32_t time,
-		 wl_fixed_t x, wl_fixed_t y)
+		 struct weston_pointer_motion_event *event)
 {
 	struct weston_pointer_drag *drag =
 		container_of(grab, struct weston_pointer_drag, grab);
@@ -338,7 +338,7 @@
 	float fx, fy;
 	wl_fixed_t sx, sy;
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 
 	if (drag->base.icon) {
 		fx = wl_fixed_to_double(pointer->x) + drag->base.dx;
@@ -407,6 +407,12 @@
 }
 
 static void
+drag_grab_axis(struct weston_pointer_grab *grab,
+	       uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+}
+
+static void
 drag_grab_cancel(struct weston_pointer_grab *grab)
 {
 	struct weston_pointer_drag *drag =
@@ -422,6 +428,7 @@
 	drag_grab_focus,
 	drag_grab_motion,
 	drag_grab_button,
+	drag_grab_axis,
 	drag_grab_cancel,
 };
 
--- a/src/input.c	2015-01-16 17:26:57.000000000 +0100
+++ b/src/input.c	2015-01-16 18:04:36.775958585 +0100
@@ -22,6 +22,7 @@
 
 #include "config.h"
 
+#include <stdbool.h>
 #include <stdlib.h>
 #include <stdint.h>
 #include <string.h>
@@ -33,6 +34,8 @@
 
 #include "../shared/os-compatibility.h"
 #include "compositor.h"
+#include "protocol/pointer-lock-server-protocol.h"
+#include "protocol/relative-pointer-server-protocol.h"
 
 static void
 empty_region(pixman_region32_t *region)
@@ -41,12 +44,62 @@
 	pixman_region32_init(region);
 }
 
+static void
+region_init_infinite(pixman_region32_t *region)
+{
+	pixman_region32_init_rect(region, INT32_MIN, INT32_MIN,
+				  UINT32_MAX, UINT32_MAX);
+}
+
 static void unbind_resource(struct wl_resource *resource)
 {
 	wl_list_remove(wl_resource_get_link(resource));
 }
 
 WL_EXPORT void
+weston_pointer_motion_to_abs(struct weston_pointer *pointer,
+			     struct weston_pointer_motion_event *event,
+			     wl_fixed_t *x, wl_fixed_t *y)
+{
+	if (event->mask & WESTON_POINTER_MOTION_ABS) {
+		*x = event->x;
+		*y = event->y;
+	} else if (event->mask & WESTON_POINTER_MOTION_REL) {
+		*x = pointer->x + event->dx;
+		*y = pointer->y + event->dy;
+	} else {
+		assert(!"invalid motion event");
+		*x = *y = 0;
+	}
+}
+
+static int
+weston_pointer_motion_to_rel(struct weston_pointer *pointer,
+			     struct weston_pointer_motion_event *event,
+			     wl_fixed_t *dx, wl_fixed_t *dy,
+			     wl_fixed_t *dx_noaccel, wl_fixed_t *dy_noaccel)
+{
+	if (event->mask & WESTON_POINTER_MOTION_REL &&
+	    event->mask & WESTON_POINTER_MOTION_REL_NOACCEL) {
+		*dx = event->dx;
+		*dy = event->dy;
+		*dx_noaccel = event->dx_noaccel;
+		*dy_noaccel = event->dy_noaccel;
+		return 1;
+	} else if (event->mask & WESTON_POINTER_MOTION_REL) {
+		*dx_noaccel = *dx = event->dx;
+		*dy_noaccel = *dy = event->dy;
+		return 1;
+	} else if (event->mask & WESTON_POINTER_MOTION_REL_NOACCEL) {
+		*dx_noaccel = *dx = event->dx_noaccel;
+		*dy_noaccel = *dy = event->dy_noaccel;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+WL_EXPORT void
 weston_seat_repick(struct weston_seat *seat)
 {
 	const struct weston_pointer *pointer = seat->pointer;
@@ -162,50 +215,96 @@
 }
 
 static void
-default_grab_pointer_motion(struct weston_pointer_grab *grab, uint32_t time,
-			    wl_fixed_t x, wl_fixed_t y)
+weston_pointer_send_relative_motion(struct weston_pointer *pointer,
+				    uint32_t time,
+				    struct weston_pointer_motion_event *event)
+{
+	wl_fixed_t dx, dy;
+	wl_fixed_t dx_noaccel, dy_noaccel;
+	struct wl_list *resource_list;
+	struct wl_resource *resource;
+
+	if (weston_pointer_motion_to_rel(pointer, event,
+					 &dx, &dy,
+					 &dx_noaccel, &dy_noaccel)) {
+		resource_list = &pointer->relative_focus_resource_list;
+		wl_resource_for_each(resource, resource_list) {
+			_wl_relative_pointer_send_relative_motion(
+				resource, time, dx, dy, dx_noaccel, dy_noaccel);
+		}
+	}
+}
+
+static void
+weston_pointer_send_motion(struct weston_pointer *pointer, uint32_t time,
+			   wl_fixed_t sx, wl_fixed_t sy)
 {
-	struct weston_pointer *pointer = grab->pointer;
 	struct wl_list *resource_list;
 	struct wl_resource *resource;
 
-	if (pointer->focus)
+	resource_list = &pointer->focus_resource_list;
+	wl_resource_for_each(resource, resource_list)
+		wl_pointer_send_motion(resource, time, sx, sy);
+}
+
+static void
+default_grab_pointer_motion(struct weston_pointer_grab *grab, uint32_t time,
+			    struct weston_pointer_motion_event *event)
+{
+	struct weston_pointer *pointer = grab->pointer;
+	wl_fixed_t x, y;
+	wl_fixed_t old_sx = pointer->sx;
+	wl_fixed_t old_sy = pointer->sy;
+
+	if (pointer->focus) {
+		weston_pointer_motion_to_abs(pointer, event, &x, &y);
 		weston_view_from_global_fixed(pointer->focus, x, y,
 					      &pointer->sx, &pointer->sy);
+	}
 
-	weston_pointer_move(pointer, x, y);
+	weston_pointer_move(pointer, event);
 
-	resource_list = &pointer->focus_resource_list;
-	wl_resource_for_each(resource, resource_list) {
-		wl_pointer_send_motion(resource, time,
-				       pointer->sx, pointer->sy);
+	if (old_sx != pointer->sx || old_sy != pointer->sy) {
+		weston_pointer_send_motion(pointer, time,
+					   pointer->sx, pointer->sy);
 	}
+
+	weston_pointer_send_relative_motion(pointer, time, event);
 }
 
 static void
-default_grab_pointer_button(struct weston_pointer_grab *grab,
-			    uint32_t time, uint32_t button, uint32_t state_w)
+weston_pointer_send_button(struct weston_pointer *pointer,
+			   uint32_t time, uint32_t button, uint32_t state_w)
 {
-	struct weston_pointer *pointer = grab->pointer;
-	struct weston_compositor *compositor = pointer->seat->compositor;
-	struct weston_view *view;
 	struct wl_resource *resource;
 	uint32_t serial;
-	enum wl_pointer_button_state state = state_w;
-	struct wl_display *display = compositor->wl_display;
-	wl_fixed_t sx, sy;
 	struct wl_list *resource_list;
+	struct wl_display *display = pointer->seat->compositor->wl_display;
 
 	resource_list = &pointer->focus_resource_list;
 	if (!wl_list_empty(resource_list)) {
 		serial = wl_display_next_serial(display);
-		wl_resource_for_each(resource, resource_list)
+		wl_resource_for_each(resource, resource_list) {
 			wl_pointer_send_button(resource,
 					       serial,
 					       time,
 					       button,
 					       state_w);
+		}
 	}
+}
+
+static void
+default_grab_pointer_button(struct weston_pointer_grab *grab,
+			    uint32_t time, uint32_t button, uint32_t state_w)
+{
+	struct weston_pointer *pointer = grab->pointer;
+	struct weston_compositor *compositor = pointer->seat->compositor;
+	struct weston_view *view;
+	enum wl_pointer_button_state state = state_w;
+	wl_fixed_t sx, sy;
+
+	weston_pointer_send_button(pointer, time, button, state_w);
 
 	if (pointer->button_count == 0 &&
 	    state == WL_POINTER_BUTTON_STATE_RELEASED) {
@@ -218,6 +317,25 @@
 }
 
 static void
+weston_pointer_send_axis(struct weston_pointer *pointer,
+			 uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	struct wl_resource *resource;
+	struct wl_list *resource_list;
+
+	resource_list = &pointer->focus_resource_list;
+	wl_resource_for_each(resource, resource_list)
+		wl_pointer_send_axis(resource, time, axis, value);
+}
+
+static void
+default_grab_pointer_axis(struct weston_pointer_grab *grab,
+			  uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	weston_pointer_send_axis(grab->pointer, time, axis, value);
+}
+
+static void
 default_grab_pointer_cancel(struct weston_pointer_grab *grab)
 {
 }
@@ -227,6 +345,7 @@
 	default_grab_pointer_focus,
 	default_grab_pointer_motion,
 	default_grab_pointer_button,
+	default_grab_pointer_axis,
 	default_grab_pointer_cancel,
 };
 
@@ -465,7 +584,9 @@
 		return NULL;
 
 	wl_list_init(&pointer->resource_list);
+	wl_list_init(&pointer->relative_resource_list);
 	wl_list_init(&pointer->focus_resource_list);
+	wl_list_init(&pointer->relative_focus_resource_list);
 	weston_pointer_set_default_grab(pointer,
 					seat->compositor->default_pointer_grab);
 	wl_list_init(&pointer->focus_resource_listener.link);
@@ -475,6 +596,7 @@
 	wl_signal_init(&pointer->motion_signal);
 	wl_signal_init(&pointer->focus_signal);
 	wl_list_init(&pointer->focus_view_listener.link);
+	wl_signal_init(&pointer->destroy_signal);
 
 	pointer->sprite_destroy_listener.notify = pointer_handle_sprite_destroy;
 
@@ -493,6 +615,8 @@
 WL_EXPORT void
 weston_pointer_destroy(struct weston_pointer *pointer)
 {
+	wl_signal_emit(&pointer->destroy_signal, pointer);
+
 	if (pointer->sprite)
 		pointer_unmap_sprite(pointer);
 
@@ -627,6 +751,7 @@
 	struct wl_display *display = pointer->seat->compositor->wl_display;
 	uint32_t serial;
 	struct wl_list *focus_resource_list;
+	struct wl_list *relative_focus_resource_list;
 	int refocus = 0;
 
 	if ((!pointer->focus && view) ||
@@ -636,6 +761,7 @@
 		refocus = 1;
 
 	focus_resource_list = &pointer->focus_resource_list;
+	relative_focus_resource_list = &pointer->relative_focus_resource_list;
 
 	if (!wl_list_empty(focus_resource_list) && refocus) {
 		serial = wl_display_next_serial(display);
@@ -645,6 +771,8 @@
 		}
 
 		move_resources(&pointer->resource_list, focus_resource_list);
+		move_resources(&pointer->relative_resource_list,
+			       relative_focus_resource_list);
 	}
 
 	if (find_resource_for_view(&pointer->resource_list, view) && refocus) {
@@ -662,6 +790,9 @@
 		move_resources_for_client(focus_resource_list,
 					  &pointer->resource_list,
 					  surface_client);
+		move_resources_for_client(relative_focus_resource_list,
+					  &pointer->relative_resource_list,
+					  surface_client);
 
 		wl_resource_for_each(resource, focus_resource_list) {
 			wl_pointer_send_enter(resource,
@@ -868,9 +999,9 @@
 		weston_pointer_clamp_for_output(pointer, prev, fx, fy);
 }
 
-/* Takes absolute values */
-WL_EXPORT void
-weston_pointer_move(struct weston_pointer *pointer, wl_fixed_t x, wl_fixed_t y)
+static void
+weston_pointer_move_to(struct weston_pointer *pointer,
+		       wl_fixed_t x, wl_fixed_t y)
 {
 	int32_t ix, iy;
 
@@ -893,6 +1024,16 @@
 	wl_signal_emit(&pointer->motion_signal, pointer);
 }
 
+WL_EXPORT void
+weston_pointer_move(struct weston_pointer *pointer,
+		    struct weston_pointer_motion_event *event)
+{
+	wl_fixed_t x, y;
+
+	weston_pointer_motion_to_abs(pointer, event, &x, &y);
+	weston_pointer_move_to(pointer, x, y);
+}
+
 /** Verify if the pointer is in a valid position and move it if it isn't.
  */
 static void
@@ -934,18 +1075,19 @@
 	fy = pointer->y;
 
 	weston_pointer_clamp_for_output(pointer, closest, &fx, &fy);
-	weston_pointer_move(pointer, fx, fy);
+	weston_pointer_move_to(pointer, fx, fy);
 }
 
 WL_EXPORT void
 notify_motion(struct weston_seat *seat,
-	      uint32_t time, wl_fixed_t dx, wl_fixed_t dy)
+	      uint32_t time,
+	      struct weston_pointer_motion_event *event)
 {
 	struct weston_compositor *ec = seat->compositor;
 	struct weston_pointer *pointer = seat->pointer;
 
 	weston_compositor_wake(ec);
-	pointer->grab->interface->motion(pointer->grab, time, pointer->x + dx, pointer->y + dy);
+	pointer->grab->interface->motion(pointer->grab, time, event);
 }
 
 static void
@@ -990,9 +1132,32 @@
 {
 	struct weston_compositor *ec = seat->compositor;
 	struct weston_pointer *pointer = seat->pointer;
+	struct weston_pointer_motion_event event = { 0 };
 
 	weston_compositor_wake(ec);
-	pointer->grab->interface->motion(pointer->grab, time, x, y);
+
+	event = (struct weston_pointer_motion_event) {
+		.mask = WESTON_POINTER_MOTION_ABS,
+		.x = x,
+		.y = y,
+	};
+
+	pointer->grab->interface->motion(pointer->grab, time, &event);
+}
+
+static unsigned int
+peek_next_activate_serial(struct weston_compositor *c)
+{
+	unsigned serial = c->activate_serial + 1;
+
+	return serial == 0 ? 1 : serial;
+}
+
+static void
+inc_activate_serial(struct weston_compositor *c)
+{
+	if (++c->activate_serial == 0)
+		++c->activate_serial;
 }
 
 WL_EXPORT void
@@ -1001,6 +1166,8 @@
 {
 	struct weston_compositor *compositor = seat->compositor;
 
+	inc_activate_serial(compositor);
+
 	if (seat->keyboard) {
 		weston_keyboard_set_focus(seat->keyboard, surface);
 		wl_data_device_set_keyboard_focus(seat);
@@ -1010,6 +1177,20 @@
 }
 
 WL_EXPORT void
+weston_view_activate(struct weston_view *view,
+		     struct weston_seat *seat,
+		     uint32_t flags)
+{
+	struct weston_compositor *compositor = seat->compositor;
+
+	if (flags & WESTON_ACTIVATE_FLAG_CLICKED) {
+		view->click_to_activate_serial =
+			peek_next_activate_serial(compositor);
+	}
+	weston_surface_activate(view->surface, seat);
+}
+
+WL_EXPORT void
 notify_button(struct weston_seat *seat, uint32_t time, int32_t button,
 	      enum wl_pointer_button_state state)
 {
@@ -1046,8 +1227,6 @@
 {
 	struct weston_compositor *compositor = seat->compositor;
 	struct weston_pointer *pointer = seat->pointer;
-	struct wl_resource *resource;
-	struct wl_list *resource_list;
 
 	weston_compositor_wake(compositor);
 
@@ -1058,10 +1237,7 @@
 						   time, axis, value))
 		return;
 
-	resource_list = &pointer->focus_resource_list;
-	wl_resource_for_each(resource, resource_list)
-		wl_pointer_send_axis(resource, time, axis,
-				     value);
+	pointer->grab->interface->axis(pointer->grab, time, axis, value);
 }
 
 WL_EXPORT int
@@ -1368,7 +1544,7 @@
 		     wl_fixed_t x, wl_fixed_t y)
 {
 	if (output) {
-		weston_pointer_move(seat->pointer, x, y);
+		weston_pointer_move_to(seat->pointer, x, y);
 	} else {
 		/* FIXME: We should call weston_pointer_set_focus(seat,
 		 * NULL) here, but somehow that breaks re-entry... */
@@ -1728,6 +1904,55 @@
 }
 
 static void
+relative_pointer_release(struct wl_client *client,
+			 struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static const struct _wl_relative_pointer_interface relative_pointer_interface = {
+	relative_pointer_release
+};
+
+static void
+seat_get_relative_pointer(struct wl_client *client,
+			  struct wl_resource *resource,
+			  uint32_t id,
+			  struct wl_resource *seat_resource)
+{
+	struct weston_seat *seat = wl_resource_get_user_data(seat_resource);
+	struct wl_resource *cr;
+	struct weston_view *focus;
+
+	if (!seat->pointer)
+		return;
+
+        cr = wl_resource_create(client, &_wl_relative_pointer_interface,
+				wl_resource_get_version(resource), id);
+	if (cr == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	/* May be moved to focused list later by either
+	 * weston_pointer_set_focus or directly if this client is already
+	 * focused */
+	wl_list_insert(&seat->pointer->relative_resource_list,
+		       wl_resource_get_link(cr));
+	wl_resource_set_implementation(cr, &relative_pointer_interface,
+				       seat->pointer,
+				       unbind_resource);
+
+	focus = seat->pointer->focus;
+	if (focus && focus->surface->resource &&
+	    wl_resource_get_client(focus->surface->resource) == client) {
+		wl_list_remove(wl_resource_get_link(cr));
+		wl_list_insert(&seat->pointer->relative_focus_resource_list,
+			       wl_resource_get_link(cr));
+	}
+}
+
+static void
 keyboard_release(struct wl_client *client, struct wl_resource *resource)
 {
 	wl_resource_destroy(resource);
@@ -1871,6 +2096,25 @@
 	seat_get_touch,
 };
 
+static const struct _wl_relative_pointer_manager_interface relative_pointer_manager = {
+	seat_get_relative_pointer,
+};
+
+static void
+bind_relative_pointer_manager(struct wl_client *client, void *data,
+			      uint32_t version, uint32_t id)
+{
+	struct weston_compositor *compositor = data;
+	struct wl_resource *resource;
+
+	resource = wl_resource_create(client,
+				      &_wl_relative_pointer_manager_interface,
+				      1, id);
+	wl_resource_set_implementation(resource, &relative_pointer_manager,
+				       compositor,
+				       NULL);
+}
+
 static void
 bind_seat(struct wl_client *client, void *data, uint32_t version, uint32_t id)
 {
@@ -2317,3 +2561,531 @@
 
 	wl_signal_emit(&seat->destroy_signal, seat);
 }
+
+static const struct _wl_locked_pointer_interface locked_pointer_interface;
+static const struct _wl_confined_pointer_interface confined_pointer_interface;
+
+static void
+pointer_lock_notify_activated(struct weston_surface *surface)
+{
+	struct weston_compositor *compositor = surface->compositor;
+	struct wl_resource *resource = surface->pointer_lock.resource;
+	uint32_t serial;
+
+	if (wl_resource_instance_of(resource,
+				    &_wl_locked_pointer_interface,
+				    &locked_pointer_interface)) {
+		serial = wl_display_next_serial(compositor->wl_display);
+		_wl_locked_pointer_send_locked(resource, serial);
+	} else if (wl_resource_instance_of(resource,
+					   &_wl_confined_pointer_interface,
+					   &confined_pointer_interface)) {
+		serial = wl_display_next_serial(compositor->wl_display);
+		_wl_confined_pointer_send_confined(resource, serial);
+	}
+}
+
+static void
+pointer_lock_notify_deactivated(struct weston_surface *surface)
+{
+	struct wl_resource *resource = surface->pointer_lock.resource;
+
+	if (wl_resource_instance_of(resource,
+				    &_wl_locked_pointer_interface,
+				    &locked_pointer_interface)) {
+		_wl_locked_pointer_send_unlocked(resource);
+	} else if (wl_resource_instance_of(resource,
+					   &_wl_confined_pointer_interface,
+					   &confined_pointer_interface)) {
+		_wl_confined_pointer_send_unconfined(resource);
+	}
+}
+
+static void
+enable_pointer_lock(struct weston_view *view,
+		    struct weston_pointer *pointer)
+{
+	struct weston_surface *surface = view->surface;
+
+	assert(surface->pointer_lock.view == NULL);
+	surface->pointer_lock.view = view;
+	pointer_lock_notify_activated(surface);
+	weston_pointer_start_grab(pointer, &surface->pointer_lock.grab);
+}
+
+static bool
+is_pointer_lock_enabled(struct weston_surface *surface)
+{
+	return surface->pointer_lock.view != NULL;
+}
+
+static void
+disable_pointer_lock(struct weston_surface *surface)
+{
+	if (is_pointer_lock_enabled(surface)) {
+		pointer_lock_notify_deactivated(surface);
+		weston_pointer_end_grab(surface->pointer_lock.grab.pointer);
+		surface->pointer_lock.view = NULL;
+	}
+
+	surface->pointer_lock.resource = NULL;
+	surface->pointer_lock.pointer = NULL;
+
+	surface->pointer_lock.hint_set = false;
+
+	wl_list_remove(&surface->pointer_lock.pointer_destroy_listener.link);
+	wl_list_remove(&surface->pointer_lock.surface_destroy_listener.link);
+	wl_list_remove(&surface->pointer_lock.surface_activate_listener.link);
+}
+
+static bool
+is_within_lock_region(struct weston_surface *surface,
+		      wl_fixed_t sx, wl_fixed_t sy)
+{
+	pixman_region32_t lock_region;
+	bool result;
+
+	pixman_region32_init(&lock_region);
+	pixman_region32_intersect(&lock_region,
+				  &surface->input,
+				  &surface->pointer_lock.region);
+	result = pixman_region32_contains_point(&lock_region,
+						wl_fixed_to_int(sx),
+						wl_fixed_to_int(sy),
+						NULL);
+	pixman_region32_fini(&lock_region);
+
+	return result;
+}
+
+static void
+maybe_enable_pointer_lock(struct weston_surface *surface)
+{
+	struct weston_view *vit;
+	struct weston_view *view = NULL;
+	struct weston_pointer *pointer = surface->pointer_lock.pointer;
+	struct weston_seat *seat = pointer->seat;
+	int32_t x, y;
+
+	/* Postpone if no view of the surface was most recently clicked. */
+	wl_list_for_each(vit, &surface->views, surface_link) {
+		if (vit->click_to_activate_serial ==
+		    surface->compositor->activate_serial) {
+			view = vit;
+		}
+	}
+	if (view == NULL)
+		return;
+
+	/* Postpone if surface doesn't have keyboard focus. */
+	if (seat->keyboard->focus != surface)
+		return;
+
+	/* Postpone lock if the pointer is not within the lock region. */
+	weston_view_from_global(view,
+				wl_fixed_to_int(pointer->x),
+				wl_fixed_to_int(pointer->y),
+				&x, &y);
+	if (!is_within_lock_region(surface,
+				   wl_fixed_from_int(x),
+				   wl_fixed_from_int(y)))
+		return;
+
+	enable_pointer_lock(view, pointer);
+}
+
+static void
+locked_pointer_grab_pointer_focus(struct weston_pointer_grab *grab)
+{
+}
+
+static void
+locked_pointer_grab_pointer_motion(struct weston_pointer_grab *grab,
+				   uint32_t time,
+				   struct weston_pointer_motion_event *event)
+{
+	weston_pointer_send_relative_motion(grab->pointer, time, event);
+}
+
+static void
+locked_pointer_grab_pointer_button(struct weston_pointer_grab *grab,
+				   uint32_t time,
+				   uint32_t button,
+				   uint32_t state_w)
+{
+	weston_pointer_send_button(grab->pointer, time, button, state_w);
+}
+
+static void
+locked_pointer_grab_pointer_axis(struct weston_pointer_grab *grab,
+				 uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+	weston_pointer_send_axis(grab->pointer, time, axis, value);
+}
+
+static void
+locked_pointer_grab_pointer_cancel(struct weston_pointer_grab *grab)
+{
+	struct weston_surface *surface =
+		container_of(grab, struct weston_surface, pointer_lock.grab);
+
+	disable_pointer_lock(surface);
+}
+
+static const struct weston_pointer_grab_interface
+				locked_pointer_grab_interface = {
+	locked_pointer_grab_pointer_focus,
+	locked_pointer_grab_pointer_motion,
+	locked_pointer_grab_pointer_button,
+	locked_pointer_grab_pointer_axis,
+	locked_pointer_grab_pointer_cancel,
+};
+
+static void
+pointer_lock_lock_resource_destroyed(struct wl_resource *resource)
+{
+	struct weston_surface *surface = wl_resource_get_user_data(resource);
+
+	if (!surface->pointer_lock.resource)
+		return;
+
+	disable_pointer_lock(surface);
+}
+
+static void
+pointer_lock_surface_activate(struct wl_listener *listener, void *data)
+{
+	struct weston_surface *focus = data;
+	struct weston_surface *locked_surface =
+		container_of(listener, struct weston_surface,
+			     pointer_lock.surface_activate_listener);
+
+	if (focus == locked_surface && !is_pointer_lock_enabled(locked_surface))
+		maybe_enable_pointer_lock(locked_surface);
+	else if (focus != locked_surface &&
+		 is_pointer_lock_enabled(locked_surface))
+		disable_pointer_lock(locked_surface);
+}
+
+static void
+pointer_lock_pointer_destroyed(struct wl_listener *listener, void *data)
+{
+	struct weston_surface *surface =
+		container_of(listener, struct weston_surface,
+			     pointer_lock.pointer_destroy_listener);
+
+	disable_pointer_lock(surface);
+}
+
+static void
+pointer_lock_surface_destroyed(struct wl_listener *listener, void *data)
+{
+	struct weston_surface *surface =
+		container_of(listener, struct weston_surface,
+			     pointer_lock.surface_destroy_listener);
+
+	disable_pointer_lock(surface);
+}
+
+static void
+init_pointer_lock(struct wl_resource *pointer_lock_resource,
+		  uint32_t id,
+		  struct weston_surface *surface,
+		  struct weston_seat *seat,
+		  struct weston_region *region,
+		  const struct wl_interface *interface,
+		  const void *implementation,
+		  const struct weston_pointer_grab_interface *grab_interface)
+{
+	struct wl_client *client =
+		wl_resource_get_client(pointer_lock_resource);
+	struct weston_pointer *pointer = seat->pointer;
+	struct wl_resource *cr;
+
+	if (surface->pointer_lock.resource) {
+		wl_resource_post_error(pointer_lock_resource,
+				       WL_DISPLAY_ERROR_INVALID_OBJECT,
+				       "pointer already locked or confined");
+		return;
+	}
+
+        cr = wl_resource_create(client, interface,
+				wl_resource_get_version(pointer_lock_resource),
+				id);
+	if (cr == NULL) {
+		wl_client_post_no_memory(client);
+		return;
+	}
+
+	wl_resource_set_implementation(cr, implementation, surface,
+				       pointer_lock_lock_resource_destroyed);
+
+	surface->pointer_lock.pointer = pointer;
+	surface->pointer_lock.resource = cr;
+	surface->pointer_lock.grab.interface = grab_interface;
+	if (region) {
+		pixman_region32_copy(&surface->pointer_lock.region,
+				     &region->region);
+	} else {
+		pixman_region32_fini(&surface->pointer_lock.region);
+		region_init_infinite(&surface->pointer_lock.region);
+	}
+
+	surface->pointer_lock.surface_activate_listener.notify =
+		pointer_lock_surface_activate;
+	surface->pointer_lock.surface_destroy_listener.notify =
+		pointer_lock_surface_destroyed;
+	surface->pointer_lock.pointer_destroy_listener.notify =
+		pointer_lock_pointer_destroyed;
+
+	wl_signal_add(&surface->compositor->activate_signal,
+		      &surface->pointer_lock.surface_activate_listener);
+	wl_signal_add(&seat->pointer->destroy_signal,
+		      &surface->pointer_lock.pointer_destroy_listener);
+	wl_signal_add(&surface->destroy_signal,
+		      &surface->pointer_lock.surface_destroy_listener);
+
+	maybe_enable_pointer_lock(surface);
+}
+
+
+static void
+locked_pointer_set_cursor_position_hint(struct wl_client *client,
+					struct wl_resource *resource,
+					uint32_t serial,
+					wl_fixed_t surface_x,
+					wl_fixed_t surface_y)
+{
+	struct weston_surface *surface = wl_resource_get_user_data(resource);
+
+	/* TODO: Check serial. */
+
+	surface->pointer_lock.hint_set = true;
+	surface->pointer_lock.x_hint = surface_x;
+	surface->pointer_lock.y_hint = surface_y;
+}
+
+static void
+locked_pointer_destroy(struct wl_client *client,
+		       struct wl_resource *resource)
+{
+	struct weston_surface *surface = wl_resource_get_user_data(resource);
+	wl_fixed_t x_hint = surface->pointer_lock.x_hint;
+	wl_fixed_t y_hint = surface->pointer_lock.y_hint;
+	wl_fixed_t x, y;
+
+	if (surface->pointer_lock.view &&
+	    surface->pointer_lock.hint_set &&
+	    is_within_lock_region(surface, x_hint, y_hint)) {
+		weston_view_to_global_fixed(surface->pointer_lock.view,
+					    x_hint, y_hint,
+					    &x, &y);
+		weston_pointer_move_to(surface->pointer_lock.pointer, x, y);
+	}
+	wl_resource_destroy(resource);
+}
+
+static const struct _wl_locked_pointer_interface locked_pointer_interface = {
+	locked_pointer_set_cursor_position_hint,
+	locked_pointer_destroy,
+};
+
+static void
+pointer_lock_lock_pointer(struct wl_client *client,
+			  struct wl_resource *resource,
+			  uint32_t id,
+			  struct wl_resource *surface_resource,
+			  struct wl_resource *seat_resource,
+			  struct wl_resource *region_resource)
+{
+	struct weston_surface *surface =
+		wl_resource_get_user_data(surface_resource);
+	struct weston_seat *seat = wl_resource_get_user_data(seat_resource);
+	struct weston_region *region = region_resource ?
+		wl_resource_get_user_data(region_resource) : NULL;
+
+	init_pointer_lock(resource, id, surface, seat, region,
+			  &_wl_locked_pointer_interface,
+			  &locked_pointer_interface,
+			  &locked_pointer_grab_interface);
+}
+
+static void
+confined_pointer_grab_pointer_focus(struct weston_pointer_grab *grab)
+{
+}
+
+static void
+weston_pointer_clamp_event_to_region(struct weston_pointer *pointer,
+				     struct weston_pointer_motion_event *event,
+				     pixman_region32_t *region,
+				     wl_fixed_t *clamped_x,
+				     wl_fixed_t *clamped_y)
+{
+	wl_fixed_t x, y;
+	wl_fixed_t sx, sy;
+	wl_fixed_t min_sx = wl_fixed_from_int(region->extents.x1);
+	wl_fixed_t max_sx = wl_fixed_from_int(region->extents.x2 - 1);
+	wl_fixed_t max_sy = wl_fixed_from_int(region->extents.y2 - 1);
+	wl_fixed_t min_sy = wl_fixed_from_int(region->extents.y1);
+
+	weston_pointer_motion_to_abs(pointer, event, &x, &y);
+	weston_view_from_global_fixed(pointer->focus, x, y, &sx, &sy);
+
+	if (sx < min_sx)
+		sx = min_sx;
+	else if (sx > max_sx)
+		sx = max_sx;
+
+	if (sy < min_sy)
+		sy = min_sy;
+	else if (sy > max_sy)
+		sy = max_sy;
+
+	weston_view_to_global_fixed(pointer->focus, sx, sy,
+				    clamped_x, clamped_y);
+}
+
+static void
+confined_pointer_grab_pointer_motion(struct weston_pointer_grab *grab,
+				     uint32_t time,
+				     struct weston_pointer_motion_event *event)
+{
+	struct weston_pointer *pointer = grab->pointer;
+	struct weston_surface *surface;
+	wl_fixed_t x, y;
+	wl_fixed_t old_sx = pointer->sx;
+	wl_fixed_t old_sy = pointer->sy;
+	pixman_region32_t confine_region;
+
+	assert(pointer->focus);
+	assert(pointer->focus->surface->pointer_lock.pointer == pointer);
+
+	surface = pointer->focus->surface;
+
+	pixman_region32_init(&confine_region);
+	pixman_region32_intersect(&confine_region,
+				  &surface->input,
+				  &surface->pointer_lock.region);
+	weston_pointer_clamp_event_to_region(pointer, event,
+					     &confine_region, &x, &y);
+	weston_pointer_move_to(pointer, x, y);
+	pixman_region32_fini(&confine_region);
+
+	weston_view_from_global_fixed(pointer->focus, x, y,
+				      &pointer->sx, &pointer->sy);
+
+	if (old_sx != pointer->sx || old_sy != pointer->sy) {
+		weston_pointer_send_motion(pointer, time,
+					   pointer->sx, pointer->sy);
+	}
+
+	weston_pointer_send_relative_motion(pointer, time, event);
+}
+
+static void
+confined_pointer_grab_pointer_button(struct weston_pointer_grab *grab,
+				     uint32_t time,
+				     uint32_t button,
+				     uint32_t state_w)
+{
+	weston_pointer_send_button(grab->pointer, time, button, state_w);
+}
+
+static void
+confined_pointer_grab_pointer_axis(struct weston_pointer_grab *grab,
+				   uint32_t time,
+				   uint32_t axis,
+				   wl_fixed_t value)
+{
+	weston_pointer_send_axis(grab->pointer, time, axis, value);
+}
+
+static void
+confined_pointer_grab_pointer_cancel(struct weston_pointer_grab *grab)
+{
+	struct weston_surface *surface =
+		container_of(grab, struct weston_surface, pointer_lock.grab);
+
+	disable_pointer_lock(surface);
+}
+
+static const struct weston_pointer_grab_interface
+				confined_pointer_grab_interface = {
+	confined_pointer_grab_pointer_focus,
+	confined_pointer_grab_pointer_motion,
+	confined_pointer_grab_pointer_button,
+	confined_pointer_grab_pointer_axis,
+	confined_pointer_grab_pointer_cancel,
+};
+
+static void
+confined_pointer_destroy(struct wl_client *client,
+			 struct wl_resource *resource)
+{
+	wl_resource_destroy(resource);
+}
+
+static const struct _wl_confined_pointer_interface confined_pointer_interface = {
+	confined_pointer_destroy,
+};
+
+static void
+pointer_lock_confine_pointer(struct wl_client *client,
+			     struct wl_resource *resource,
+			     uint32_t id,
+			     struct wl_resource *surface_resource,
+			     struct wl_resource *seat_resource,
+			     struct wl_resource *region_resource)
+{
+	struct weston_surface *surface =
+		wl_resource_get_user_data(surface_resource);
+	struct weston_seat *seat = wl_resource_get_user_data(seat_resource);
+	struct weston_region *region = region_resource ?
+		wl_resource_get_user_data(region_resource) : NULL;
+
+	if ((region && pixman_region32_n_rects(&region->region) != 1) ||
+	    pixman_region32_n_rects(&surface->input) != 1) {
+		weston_log("warning: confinement only implemented for"
+			   "rectangular regions\n");
+		return;
+	}
+
+	init_pointer_lock(resource, id, surface, seat, region,
+			  &_wl_confined_pointer_interface,
+			  &confined_pointer_interface,
+			  &confined_pointer_grab_interface);
+}
+
+static const struct _wl_pointer_lock_interface pointer_lock_interface = {
+	pointer_lock_lock_pointer,
+	pointer_lock_confine_pointer,
+};
+
+static void
+bind_pointer_lock(struct wl_client *client, void *data,
+		  uint32_t version, uint32_t id)
+{
+	struct wl_resource *resource;
+
+	resource = wl_resource_create(client, &_wl_pointer_lock_interface,
+				      1, id);
+	wl_resource_set_implementation(resource, &pointer_lock_interface,
+				       NULL, NULL);
+}
+
+int
+weston_input_init(struct weston_compositor *compositor)
+{
+	if (!wl_global_create(compositor->wl_display,
+			      &_wl_relative_pointer_manager_interface, 1,
+			      compositor, bind_relative_pointer_manager))
+		return -1;
+
+	if (!wl_global_create(compositor->wl_display,
+			      &_wl_pointer_lock_interface, 1,
+			      NULL, bind_pointer_lock))
+		return -1;
+
+	return 0;
+}
--- a/src/libinput-device.c	2015-01-16 17:26:57.000000000 +0100
+++ b/src/libinput-device.c	2015-01-16 18:04:36.780958665 +0100
@@ -73,14 +73,24 @@
 {
 	struct evdev_device *device =
 		libinput_device_get_user_data(libinput_device);
-	wl_fixed_t dx, dy;
+	struct weston_pointer_motion_event event = { 0 };
+
+	event = (struct weston_pointer_motion_event) {
+		.mask = WESTON_POINTER_MOTION_REL |
+			WESTON_POINTER_MOTION_REL_NOACCEL,
+		.dx = wl_fixed_from_double(
+			libinput_event_pointer_get_dx(pointer_event)),
+		.dy = wl_fixed_from_double(
+			libinput_event_pointer_get_dy(pointer_event)),
+		.dx_noaccel = wl_fixed_from_double(
+			libinput_event_pointer_get_dx_unaccelerated(pointer_event)),
+		.dy_noaccel = wl_fixed_from_double(
+			libinput_event_pointer_get_dy_unaccelerated(pointer_event)),
+	};
 
-	dx = wl_fixed_from_double(libinput_event_pointer_get_dx(pointer_event));
-	dy = wl_fixed_from_double(libinput_event_pointer_get_dy(pointer_event));
 	notify_motion(device->seat,
 		      libinput_event_pointer_get_time(pointer_event),
-		      dx,
-		      dy);
+		      &event);
 }
 
 static void
--- a/tests/weston-test.c	2015-01-16 17:26:57.000000000 +0100
+++ b/tests/weston-test.c	2015-01-16 18:04:36.744958088 +0100
@@ -144,10 +144,15 @@
 	struct weston_test *test = wl_resource_get_user_data(resource);
 	struct weston_seat *seat = get_seat(test);
 	struct weston_pointer *pointer = seat->pointer;
+	struct weston_pointer_motion_event event = { 0 };
 
-	notify_motion(seat, 100,
-		      wl_fixed_from_int(x) - pointer->x,
-		      wl_fixed_from_int(y) - pointer->y);
+	event = (struct weston_pointer_motion_event) {
+		.mask = WESTON_POINTER_MOTION_REL,
+		.dx = wl_fixed_from_int(x) - pointer->x,
+		.dy = wl_fixed_from_int(y) - pointer->y,
+	};
+
+	notify_motion(seat, 100, &event);
 
 	notify_pointer_position(test, resource);
 }
