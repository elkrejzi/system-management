Re-add support for lbarx, lharx, stbcx. and sthcx. insns back to the E6500 cpu.

--- a/bfd/archive.c	2016-01-25 09:51:06.000000000 +0100
+++ b/bfd/archive.c	2016-06-05 12:51:34.118313534 +0200
@@ -802,7 +802,7 @@
 	     Note that last_file->origin can be odd in the case of
 	     BSD-4.4-style element with a long odd size.  */
 	  filestart += filestart % 2;
-	  if (filestart <= last_file->proxy_origin)
+	  if (filestart < last_file->proxy_origin)
 	    {
 	      /* Prevent looping.  See PR19256.  */
 	      bfd_set_error (bfd_error_malformed_archive);
--- a/bfd/dwarf2.c	2016-01-25 09:51:06.000000000 +0100
+++ b/bfd/dwarf2.c	2016-06-05 12:51:34.119313560 +0200
@@ -3706,8 +3706,10 @@
 	   fail more quickly.  */
 	return FALSE;
 
+      /* Set BFD_DECOMPRESS to decompress debug sections.  */
       if ((debug_bfd = bfd_openr (debug_filename, NULL)) == NULL
-	  || ! bfd_check_format (debug_bfd, bfd_object)
+	  || !(debug_bfd->flags |= BFD_DECOMPRESS,
+	       bfd_check_format (debug_bfd, bfd_object))
 	  || (msec = find_debug_info (debug_bfd,
 				      debug_sections, NULL)) == NULL
 	  || !bfd_generic_link_read_symbols (debug_bfd))
--- a/bfd/elf32-i386.c	2016-01-25 09:51:06.000000000 +0100
+++ b/bfd/elf32-i386.c	2016-06-05 12:53:33.893408887 +0200
@@ -1830,7 +1830,8 @@
 	       && (sec->flags & SEC_ALLOC) != 0
 	       && (r_type != R_386_PC32
 		   || (h != NULL
-		       && (! SYMBOLIC_BIND (info, h)
+		       && (! (bfd_link_pie (info)
+			      || SYMBOLIC_BIND (info, h))
 			   || h->root.type == bfd_link_hash_defweak
 			   || !h->def_regular))))
 	      || (ELIMINATE_COPY_RELOCS
@@ -1961,7 +1962,7 @@
 	    return FALSE;
 	}
 
-      if ((r_type == R_386_GOT32 || r_type == R_386_GOT32X)
+      if (r_type == R_386_GOT32X
 	  && (h == NULL || h->type != STT_GNU_IFUNC))
 	sec->need_convert_load = 1;
     }
@@ -2490,12 +2491,14 @@
 	}
       else
 	{
+	  eh->plt_got.offset = (bfd_vma) -1;
 	  h->plt.offset = (bfd_vma) -1;
 	  h->needs_plt = 0;
 	}
     }
   else
     {
+      eh->plt_got.offset = (bfd_vma) -1;
       h->plt.offset = (bfd_vma) -1;
       h->needs_plt = 0;
     }
@@ -2813,14 +2816,16 @@
       unsigned int nop;
       bfd_vma nop_offset;
 
-      if (r_type != R_386_GOT32 && r_type != R_386_GOT32X)
+      /* Don't convert R_386_GOT32 since we can't tell if it is applied
+	 to "mov $foo@GOT, %reg" which isn't a load via GOT.  */
+      if (r_type != R_386_GOT32X)
 	continue;
 
       roff = irel->r_offset;
       if (roff < 2)
 	continue;
 
-      /* Addend for R_386_GOT32 and R_386_GOT32X relocations must be 0.  */
+      /* Addend for R_386_GOT32X relocation must be 0.  */
       addend = bfd_get_32 (abfd, contents + roff);
       if (addend != 0)
 	continue;
@@ -2828,13 +2833,11 @@
       modrm = bfd_get_8 (abfd, contents + roff - 1);
       baseless = (modrm & 0xc7) == 0x5;
 
-      if (r_type == R_386_GOT32X
-	  && baseless
+      if (baseless
 	  && bfd_link_pic (link_info))
 	{
 	  /* For PIC, disallow R_386_GOT32X without a base register
-	     since we don't know what the GOT base is.   Allow
-	     R_386_GOT32 for existing object files.  */
+	     since we don't know what the GOT base is.  */
 	  const char *name;
 
 	  if (r_symndx < symtab_hdr->sh_info)
@@ -2862,12 +2865,6 @@
       /* It is OK to convert mov to lea.  */
       if (opcode != 0x8b)
 	{
-	  /* Only convert R_386_GOT32X relocation for call, jmp or
-	     one of adc, add, and, cmp, or, sbb, sub, test, xor
-	     instructions.  */
-	  if (r_type != R_386_GOT32X)
-	    continue;
-
 	  /* It is OK to convert indirect branch to direct branch.  It
 	     is OK to convert adc, add, and, cmp, or, sbb, sub, test,
 	     xor only when PIC is false.   */
@@ -2875,8 +2872,8 @@
 	    continue;
 	}
 
-      /* Try to convert R_386_GOT32 and R_386_GOT32X.  Get the symbol
-	 referred to by the reloc.  */
+      /* Try to convert R_386_GOT32X.  Get the symbol referred to by
+         the reloc.  */
       if (r_symndx < symtab_hdr->sh_info)
 	{
 	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
@@ -2988,8 +2985,7 @@
 		{
 		  /* Convert "mov foo@GOT(%reg1), %reg2" to
 		     "lea foo@GOTOFF(%reg1), %reg2".  */
-		  if (r_type == R_386_GOT32X
-		      && (baseless || !bfd_link_pic (link_info)))
+		  if (baseless || !bfd_link_pic (link_info))
 		    {
 		      r_type = R_386_32;
 		      /* For R_386_32, convert
@@ -4016,10 +4012,12 @@
 
 	  /* It is relative to .got.plt section.  */
 	  if (h->got.offset != (bfd_vma) -1)
-	    /* Use GOT entry.  */
+	    /* Use GOT entry.  Mask off the least significant bit in
+	       GOT offset which may be set by R_386_GOT32 processing
+	       below.  */
 	    relocation = (htab->elf.sgot->output_section->vma
 			  + htab->elf.sgot->output_offset
-			  + h->got.offset - offplt);
+			  + (h->got.offset & ~1) - offplt);
 	  else
 	    /* Use GOTPLT entry.  */
 	    relocation = (h->plt.offset / plt_entry_size - 1 + 3) * 4;
@@ -4285,8 +4283,8 @@
 	      else if (h != NULL
 		       && h->dynindx != -1
 		       && (r_type == R_386_PC32
-			   || !bfd_link_pic (info)
-			   || !SYMBOLIC_BIND (info, h)
+			   || !(bfd_link_executable (info)
+				|| SYMBOLIC_BIND (info, h))
 			   || !h->def_regular))
 		outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
 	      else
@@ -5355,19 +5353,23 @@
   bfd *abfd = info->output_bfd;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   struct elf_link_hash_table *htab = elf_hash_table (info);
-  unsigned long r_symndx = ELF32_R_SYM (rela->r_info);
-  Elf_Internal_Sym sym;
 
-  if (htab->dynsym == NULL
-      || !bed->s->swap_symbol_in (abfd,
-				  (htab->dynsym->contents
-				   + r_symndx * sizeof (Elf32_External_Sym)),
-				  0, &sym))
-    abort ();
+  if (htab->dynsym != NULL
+      && htab->dynsym->contents != NULL)
+    {
+      /* Check relocation against STT_GNU_IFUNC symbol if there are
+         dynamic symbols.  */
+      unsigned long r_symndx = ELF32_R_SYM (rela->r_info);
+      Elf_Internal_Sym sym;
+      if (!bed->s->swap_symbol_in (abfd,
+				   (htab->dynsym->contents
+				    + r_symndx * sizeof (Elf32_External_Sym)),
+				   0, &sym))
+	abort ();
 
-  /* Check relocation against STT_GNU_IFUNC symbol.  */
-  if (ELF32_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
-    return reloc_class_ifunc;
+      if (ELF32_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+	return reloc_class_ifunc;
+    }
 
   switch (ELF32_R_TYPE (rela->r_info))
     {
--- a/bfd/elf64-x86-64.c	2016-01-25 09:51:06.000000000 +0100
+++ b/bfd/elf64-x86-64.c	2016-06-05 12:53:07.307721688 +0200
@@ -2029,7 +2029,8 @@
 	       && (sec->flags & SEC_ALLOC) != 0
 	       && (! IS_X86_64_PCREL_TYPE (r_type)
 		   || (h != NULL
-		       && (! SYMBOLIC_BIND (info, h)
+		       && (! (bfd_link_pie (info)
+			      || SYMBOLIC_BIND (info, h))
 			   || h->root.type == bfd_link_hash_defweak
 			   || !h->def_regular))))
 	      || (ELIMINATE_COPY_RELOCS
@@ -2723,12 +2724,14 @@
 	}
       else
 	{
+	  eh->plt_got.offset = (bfd_vma) -1;
 	  h->plt.offset = (bfd_vma) -1;
 	  h->needs_plt = 0;
 	}
     }
   else
     {
+      eh->plt_got.offset = (bfd_vma) -1;
       h->plt.offset = (bfd_vma) -1;
       h->needs_plt = 0;
     }
@@ -3151,6 +3154,11 @@
 	    continue;
 	}
 
+      /* Don't convert GOTPCREL relocation against large section.  */
+      if (elf_section_data (tsec) !=  NULL
+	  && (elf_section_flags (tsec) & SHF_X86_64_LARGE) != 0)
+	continue;
+
       if (tsec->sec_info_type == SEC_INFO_TYPE_MERGE)
 	{
 	  /* At this stage in linking, no SEC_MERGE symbol has been
@@ -3190,35 +3198,46 @@
 	}
       else
 	{
-	  asection *asect;
-	  bfd_size_type size;
+	  bfd_signed_vma distance;
 
 	  /* At this point, we don't know the load addresses of TSEC
 	     section nor SEC section.  We estimate the distrance between
-	     SEC and TSEC.  */
-	  size = 0;
-	  for (asect = sec->output_section;
-	       asect != NULL && asect != tsec->output_section;
-	       asect = asect->next)
-	    {
-	      asection *i;
-	      for (i = asect->output_section->map_head.s;
-		   i != NULL;
-		   i = i->map_head.s)
-		{
-		  size = align_power (size, i->alignment_power);
-		  size += i->size;
-		}
+	     SEC and TSEC.  We store the estimated distances in the
+	     compressed_size field of the output section, which is only
+	     used to decompress the compressed input section.  */
+	  if (sec->output_section->compressed_size == 0)
+	    {
+	      asection *asect;
+	      bfd_size_type size = 0;
+	      for (asect = link_info->output_bfd->sections;
+		   asect != NULL;
+		   asect = asect->next)
+		/* Skip debug sections since compressed_size is used to
+		   compress debug sections.  */
+		if ((asect->flags & SEC_DEBUGGING) == 0)
+		  {
+		    asection *i;
+		    for (i = asect->map_head.s;
+			 i != NULL;
+			 i = i->map_head.s)
+		      {
+			size = align_power (size, i->alignment_power);
+			size += i->size;
+		      }
+		    asect->compressed_size = size;
+		  }
 	    }
 
 	  /* Don't convert GOTPCREL relocations if TSEC isn't placed
 	     after SEC.  */
-	  if (asect == NULL)
+	  distance = (tsec->output_section->compressed_size
+		      - sec->output_section->compressed_size);
+	  if (distance < 0)
 	    continue;
 
 	  /* Take PT_GNU_RELRO segment into account by adding
 	     maxpagesize.  */
-	  if ((toff + size + maxpagesize - roff + 0x80000000)
+	  if ((toff + distance + maxpagesize - roff + 0x80000000)
 	      > 0xffffffff)
 	    continue;
 	}
@@ -4631,8 +4650,8 @@
 	      else if (h != NULL
 		       && h->dynindx != -1
 		       && (IS_X86_64_PCREL_TYPE (r_type)
-			   || ! bfd_link_pic (info)
-			   || ! SYMBOLIC_BIND (info, h)
+			   || !(bfd_link_executable (info)
+				|| SYMBOLIC_BIND (info, h))
 			   || ! h->def_regular))
 		{
 		  outrel.r_info = htab->r_info (h->dynindx, r_type);
@@ -5728,19 +5747,23 @@
   bfd *abfd = info->output_bfd;
   const struct elf_backend_data *bed = get_elf_backend_data (abfd);
   struct elf_x86_64_link_hash_table *htab = elf_x86_64_hash_table (info);
-  unsigned long r_symndx = htab->r_sym (rela->r_info);
-  Elf_Internal_Sym sym;
 
-  if (htab->elf.dynsym == NULL
-      || !bed->s->swap_symbol_in (abfd,
-				  (htab->elf.dynsym->contents
-				   + r_symndx * bed->s->sizeof_sym),
-				  0, &sym))
-    abort ();
+  if (htab->elf.dynsym != NULL
+      && htab->elf.dynsym->contents != NULL)
+    {
+      /* Check relocation against STT_GNU_IFUNC symbol if there are
+         dynamic symbols.  */
+      unsigned long r_symndx = htab->r_sym (rela->r_info);
+      Elf_Internal_Sym sym;
+      if (!bed->s->swap_symbol_in (abfd,
+				   (htab->elf.dynsym->contents
+				    + r_symndx * bed->s->sizeof_sym),
+				   0, &sym))
+	abort ();
 
-  /* Check relocation against STT_GNU_IFUNC symbol.  */
-  if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
-    return reloc_class_ifunc;
+      if (ELF_ST_TYPE (sym.st_info) == STT_GNU_IFUNC)
+	return reloc_class_ifunc;
+    }
 
   switch ((int) ELF32_R_TYPE (rela->r_info))
     {
--- a/bfd/elflink.c	2016-01-25 09:51:06.000000000 +0100
+++ b/bfd/elflink.c	2016-06-05 12:51:34.124313689 +0200
@@ -555,6 +555,19 @@
   if (h == NULL)
     return provide;
 
+  if (h->versioned == unknown)
+    {
+      /* Set versioned if symbol version is unknown.  */
+      char *version = strrchr (name, ELF_VER_CHR);
+      if (version)
+	{
+	  if (version > name && version[-1] != ELF_VER_CHR)
+	    h->versioned = versioned_hidden;
+	  else
+	    h->versioned = versioned;
+	}
+    }
+
   switch (h->root.type)
     {
     case bfd_link_hash_defined:
@@ -1472,13 +1485,16 @@
      represent variables; this can cause confusion in principle, but
      any such confusion would seem to indicate an erroneous program or
      shared library.  We also permit a common symbol in a regular
-     object to override a weak symbol in a shared object.  */
+     object to override a weak symbol in a shared object.  A common
+     symbol in executable also overrides a symbol in a shared object.  */
 
   if (newdyn
       && newdef
       && (olddef
 	  || (h->root.type == bfd_link_hash_common
-	      && (newweak || newfunc))))
+	      && (newweak
+		  || newfunc
+		  || (!olddyn && bfd_link_executable (info))))))
     {
       *override = TRUE;
       newdef = FALSE;
@@ -4562,8 +4578,10 @@
 		break;
 	      }
 
-	  /* Don't add DT_NEEDED for references from the dummy bfd.  */
+	  /* Don't add DT_NEEDED for references from the dummy bfd nor
+	     for unmatched symbol.  */
 	  if (!add_needed
+	      && matched
 	      && definition
 	      && ((dynsym
 		   && h->ref_regular_nonweak
--- a/binutils/Makefile.am	2015-11-13 09:27:40.000000000 +0100
+++ b/binutils/Makefile.am	2016-06-05 12:51:34.125313715 +0200
@@ -192,6 +192,7 @@
 	EXPECT=$(EXPECT); export EXPECT; \
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  CC="$(CC)" CC_FOR_BUILD="$(CC_FOR_BUILD)" \
 	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(CFLAGS)" \
 		$$runtest --tool $(DEJATOOL) --srcdir $${srcdir}/testsuite \
 			$(RUNTESTFLAGS); \
--- a/binutils/Makefile.in	2015-11-13 09:27:40.000000000 +0100
+++ b/binutils/Makefile.in	2016-06-05 12:51:34.125313715 +0200
@@ -1290,6 +1290,7 @@
 	EXPECT=$(EXPECT); export EXPECT; \
 	runtest=$(RUNTEST); \
 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+	  CC="$(CC)" CC_FOR_BUILD="$(CC_FOR_BUILD)" \
 	  CC_FOR_TARGET="$(CC_FOR_TARGET)" CFLAGS_FOR_TARGET="$(CFLAGS)" \
 		$$runtest --tool $(DEJATOOL) --srcdir $${srcdir}/testsuite \
 			$(RUNTESTFLAGS); \
--- a/gas/config/tc-i386.c	2016-01-25 09:51:06.000000000 +0100
+++ b/gas/config/tc-i386.c	2016-06-05 12:51:34.126313741 +0200
@@ -552,6 +552,10 @@
    specified explicitly.  */
 static int omit_lock_prefix = 0;
 
+/* 1 if the assembler should generate relax relocations.  */
+static int generate_relax_relocations
+  = DEFAULT_GENERATE_X86_RELAX_RELOCATIONS;
+
 static enum check_kind
   {
     check_none = 0,
@@ -1871,6 +1875,9 @@
   if (r->reg_flags & RegRex)
     nr += 8;
 
+  if (r->reg_flags & RegVRex)
+    nr += 16;
+
   return nr;
 }
 
@@ -4557,7 +4564,9 @@
 	    && i.op[op].disps->X_op == O_constant)
 	  {
 	    offsetT value = i.op[op].disps->X_add_number;
-	    int vec_disp8_ok = fits_in_vec_disp8 (value);
+	    int vec_disp8_ok
+	      = (i.disp_encoding != disp_encoding_32bit
+		 && fits_in_vec_disp8 (value));
 	    if (t->operand_types [op].bitfield.vec_disp8)
 	      {
 		if (vec_disp8_ok)
@@ -7241,9 +7250,14 @@
 	      /* Check for "call/jmp *mem", "mov mem, %reg",
 		 "test %reg, mem" and "binop mem, %reg" where binop
 		 is one of adc, add, and, cmp, or, sbb, sub, xor
-		 instructions.  */
-	      if ((i.rm.mode == 2
-		   || (i.rm.mode == 0 && i.rm.regmem == 5))
+		 instructions.  Always generate R_386_GOT32X for
+		 "sym*GOT" operand in 32-bit mode.  */
+	      if ((generate_relax_relocations
+		   || (!object_64bit
+		       && i.rm.mode == 0
+		       && i.rm.regmem == 5))
+		  && (i.rm.mode == 2
+		      || (i.rm.mode == 0 && i.rm.regmem == 5))
 		  && ((i.operands == 1
 		       && i.tm.base_opcode == 0xff
 		       && (i.rm.reg == 2 || i.rm.reg == 4))
@@ -9616,6 +9630,7 @@
 #define OPTION_MSHARED (OPTION_MD_BASE + 21)
 #define OPTION_MAMD64 (OPTION_MD_BASE + 22)
 #define OPTION_MINTEL64 (OPTION_MD_BASE + 23)
+#define OPTION_MRELAX_RELOCATIONS (OPTION_MD_BASE + 24)
 
 struct option md_longopts[] =
 {
@@ -9647,6 +9662,7 @@
   {"mbig-obj", no_argument, NULL, OPTION_MBIG_OBJ},
 #endif
   {"momit-lock-prefix", required_argument, NULL, OPTION_OMIT_LOCK_PREFIX},
+  {"mrelax-relocations", required_argument, NULL, OPTION_MRELAX_RELOCATIONS},
   {"mevexrcig", required_argument, NULL, OPTION_MEVEXRCIG},
   {"mamd64", no_argument, NULL, OPTION_MAMD64},
   {"mintel64", no_argument, NULL, OPTION_MINTEL64},
@@ -9966,6 +9982,15 @@
         as_fatal (_("invalid -momit-lock-prefix= option: `%s'"), arg);
       break;
 
+    case OPTION_MRELAX_RELOCATIONS:
+      if (strcasecmp (arg, "yes") == 0)
+        generate_relax_relocations = 1;
+      else if (strcasecmp (arg, "no") == 0)
+        generate_relax_relocations = 0;
+      else
+        as_fatal (_("invalid -mrelax-relocations= option: `%s'"), arg);
+      break;
+
     case OPTION_MAMD64:
       cpu_arch_flags.bitfield.cpuamd64 = 1;
       cpu_arch_flags.bitfield.cpuintel64 = 0;
@@ -10146,6 +10171,9 @@
   -momit-lock-prefix=[no|yes]\n\
                           strip all lock prefixes\n"));
   fprintf (stream, _("\
+  -mrelax-relocations=[no|yes]\n\
+                          generate relax relocations\n"));
+  fprintf (stream, _("\
   -mamd64                 accept only AMD64 ISA\n"));
   fprintf (stream, _("\
   -mintel64               accept only Intel64 ISA\n"));
--- a/gas/config.in	2015-11-13 09:27:41.000000000 +0100
+++ b/gas/config.in	2016-06-05 12:51:34.127313766 +0200
@@ -39,6 +39,9 @@
 /* Define if you want compressed debug sections by default. */
 #undef DEFAULT_FLAG_COMPRESS_DEBUG
 
+/* Define to 1 if you want to generate x86 relax relocations by default. */
+#undef DEFAULT_GENERATE_X86_RELAX_RELOCATIONS
+
 /* Supported emulations. */
 #undef EMULATIONS
 
--- a/gas/configure	2016-01-25 09:54:08.000000000 +0100
+++ b/gas/configure	2016-06-05 12:51:34.129313818 +0200
@@ -765,6 +765,7 @@
 enable_targets
 enable_checking
 enable_compressed_debug_sections
+enable_x86_relax_relocations
 enable_werror
 enable_build_warnings
 enable_nls
@@ -1415,6 +1416,8 @@
   --enable-checking       enable run-time checks
   --enable-compressed-debug-sections={all,gas,none}
                           compress debug sections by default]
+  --enable-x86-relax-relocations
+                          generate x86 relax relocations by default
   --enable-werror         treat compile warnings as errors
   --enable-build-warnings enable build-time compiler warnings
   --disable-nls           do not use Native Language Support
@@ -10972,7 +10975,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 10975 "configure"
+#line 10978 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11078,7 +11081,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11081 "configure"
+#line 11084 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11680,6 +11683,17 @@
 esac
 fi
 
+# PR gas/19520
+# Decide if x86 assembler should generate relax relocations.
+ac_default_x86_relax_relocations=unset
+# Provide a configure time option to override our default.
+# Check whether --enable-x86_relax_relocations was given.
+if test "${enable_x86_relax_relocations+set}" = set; then :
+  enableval=$enable_x86_relax_relocations; case "${enableval}" in
+  no)  ac_default_x86_relax_relocations=0 ;;
+esac
+fi
+
 using_cgen=no
 
 
@@ -12085,6 +12099,17 @@
 
 	;;
 
+      i386-*-solaris2 \
+      | x86_64-*-solaris2 \
+      | i386-*-solaris2.[0-9] \
+      | i386-*-solaris2.1[01] \
+      | x86_64-*-solaris2.1[01])
+	if test ${this_target} = $target \
+	   && test ${ac_default_x86_relax_relocations} = unset; then
+	  ac_default_x86_relax_relocations=0
+	fi
+	;;
+
       i860-*-*)
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: GAS support for ${generic_target} is preliminary and a work in progress" >&5
 $as_echo "$as_me: WARNING: GAS support for ${generic_target} is preliminary and a work in progress" >&2;}
@@ -12505,7 +12530,16 @@
 
 done
 
-if test x$ac_default_compressed_debug_sections == xyes ; then
+if test ${ac_default_x86_relax_relocations} = unset; then
+  ac_default_x86_relax_relocations=1
+fi
+
+cat >>confdefs.h <<_ACEOF
+#define DEFAULT_GENERATE_X86_RELAX_RELOCATIONS $ac_default_x86_relax_relocations
+_ACEOF
+
+
+if test x$ac_default_compressed_debug_sections = xyes ; then
 
 $as_echo "#define DEFAULT_FLAG_COMPRESS_DEBUG 1" >>confdefs.h
 
--- a/gas/configure.ac	2016-01-25 09:51:06.000000000 +0100
+++ b/gas/configure.ac	2016-06-05 12:51:34.129313818 +0200
@@ -77,6 +77,17 @@
   *)   ac_default_compressed_debug_sections=unset ;;
 esac])dnl
 
+# PR gas/19520
+# Decide if x86 assembler should generate relax relocations.
+ac_default_x86_relax_relocations=unset
+# Provide a configure time option to override our default.
+AC_ARG_ENABLE(x86_relax_relocations,
+	      AS_HELP_STRING([--enable-x86-relax-relocations],
+	      [generate x86 relax relocations by default]),
+[case "${enableval}" in
+  no)  ac_default_x86_relax_relocations=0 ;;
+esac])dnl
+
 using_cgen=no
 
 AM_BINUTILS_WARNINGS
@@ -168,6 +179,17 @@
 	AC_DEFINE(STRICTCOFF, 1, [Using strict COFF?])
 	;;
 
+      i386-*-solaris2 \
+      | x86_64-*-solaris2 \
+      | i386-*-solaris2.[[0-9]] \
+      | i386-*-solaris2.1[[01]] \
+      | x86_64-*-solaris2.1[[01]])
+	if test ${this_target} = $target \
+	   && test ${ac_default_x86_relax_relocations} = unset; then
+	  ac_default_x86_relax_relocations=0
+	fi
+	;;
+
       i860-*-*)
 	AC_MSG_WARN(GAS support for ${generic_target} is preliminary and a work in progress)
 	;;
@@ -549,7 +571,14 @@
 
 done
 
-if test x$ac_default_compressed_debug_sections == xyes ; then
+if test ${ac_default_x86_relax_relocations} = unset; then
+  ac_default_x86_relax_relocations=1
+fi
+AC_DEFINE_UNQUOTED(DEFAULT_GENERATE_X86_RELAX_RELOCATIONS,
+  $ac_default_x86_relax_relocations,
+  [Define to 1 if you want to generate x86 relax relocations by default.])
+
+if test x$ac_default_compressed_debug_sections = xyes ; then
   AC_DEFINE(DEFAULT_FLAG_COMPRESS_DEBUG, 1, [Define if you want compressed debug sections by default.])
 fi
 
--- a/gold/icf.cc	2015-11-13 09:27:42.000000000 +0100
+++ b/gold/icf.cc	2016-06-05 12:51:57.900928011 +0200
@@ -213,6 +213,45 @@
     }
 }
 
+// For SHF_MERGE sections that use REL relocations, the addend is stored in
+// the text section at the relocation offset.  Read  the addend value given
+// the pointer to the addend in the text section and the addend size.
+// Update the addend value if a valid addend is found.
+// Parameters:
+// RELOC_ADDEND_PTR   : Pointer to the addend in the text section.
+// ADDEND_SIZE        : The size of the addend.
+// RELOC_ADDEND_VALUE : Pointer to the addend that is updated.
+
+inline void
+get_rel_addend(const unsigned char* reloc_addend_ptr,
+	       const unsigned int addend_size,
+	       uint64_t* reloc_addend_value)
+{
+  switch (addend_size)
+    {
+    case 0:
+      break;
+    case 1:
+      *reloc_addend_value =
+        read_from_pointer<8>(reloc_addend_ptr);
+      break;
+    case 2:
+      *reloc_addend_value =
+          read_from_pointer<16>(reloc_addend_ptr);
+      break;
+    case 4:
+      *reloc_addend_value =
+        read_from_pointer<32>(reloc_addend_ptr);
+      break;
+    case 8:
+      *reloc_addend_value =
+        read_from_pointer<64>(reloc_addend_ptr);
+      break;
+    default:
+      gold_unreachable();
+    }
+}
+
 // This returns the buffer containing the section's contents, both
 // text and relocs.  Relocs are differentiated as those pointing to
 // sections that could be folded and those that cannot.  Only relocs
@@ -397,58 +436,36 @@
                   uint64_t entsize =
                     (it_v->first)->section_entsize(it_v->second);
 		  long long offset = it_a->first;
-
-                  unsigned long long addend = it_a->second;
-                  // Ignoring the addend when it is a negative value.  See the 
-                  // comments in Merged_symbol_value::Value in object.h.
-                  if (addend < 0xffffff00)
-                    offset = offset + addend;
-
-		  // For SHT_REL relocation sections, the addend is stored in the
-		  // text section at the relocation offset.
-		  uint64_t reloc_addend_value = 0;
+		  // Handle SHT_RELA and SHT_REL addends, only one of these
+		  // addends exists.
+		  // Get the SHT_RELA addend.  For RELA relocations, we have
+		  // the addend from the relocation.
+		  uint64_t reloc_addend_value = it_a->second;
+
+		  // Handle SHT_REL addends.
+		  // For REL relocations, we need to fetch the addend from the
+		  // section contents.
                   const unsigned char* reloc_addend_ptr =
 		    contents + static_cast<unsigned long long>(*it_o);
-		  switch(*it_addend_size)
-		    {
-		      case 0:
-		        {
-                          break;
-                        }
-                      case 1:
-                        {
-                          reloc_addend_value =
-                            read_from_pointer<8>(reloc_addend_ptr);
-			  break;
-                        }
-                      case 2:
-                        {
-                          reloc_addend_value =
-                            read_from_pointer<16>(reloc_addend_ptr);
-			  break;
-                        }
-                      case 4:
-                        {
-                          reloc_addend_value =
-                            read_from_pointer<32>(reloc_addend_ptr);
-			  break;
-                        }
-                      case 8:
-                        {
-                          reloc_addend_value =
-                            read_from_pointer<64>(reloc_addend_ptr);
-			  break;
-                        }
-		      default:
-		        gold_unreachable();
-		    }
-		  offset = offset + reloc_addend_value;
+
+		  // Update the addend value with the SHT_REL addend if
+		  // available.
+		  get_rel_addend(reloc_addend_ptr, *it_addend_size,
+				 &reloc_addend_value);
+
+		  // Ignore the addend when it is a negative value.  See the
+		  // comments in Merged_symbol_value::value in object.h.
+		  if (reloc_addend_value < 0xffffff00)
+		    offset = offset + reloc_addend_value;
 
                   section_size_type secn_len;
+
                   const unsigned char* str_contents =
                   (it_v->first)->section_contents(it_v->second,
                                                   &secn_len,
                                                   false) + offset;
+		  gold_assert (offset < (long long) secn_len);
+
                   if ((secn_flags & elfcpp::SHF_STRINGS) != 0)
                     {
                       // String merge section.
@@ -489,10 +506,14 @@
                     }
                   else
                     {
-                      // Use the entsize to determine the length.
-                      buffer.append(reinterpret_cast<const 
+                      // Use the entsize to determine the length to copy.
+		      uint64_t bufsize = entsize;
+		      // If entsize is too big, copy all the remaining bytes.
+		      if ((offset + entsize) > secn_len)
+			bufsize = secn_len - offset;
+                      buffer.append(reinterpret_cast<const
                                                      char*>(str_contents),
-                                    entsize);
+                                    bufsize);
                     }
 		  buffer.append("@");
                 }
--- a/ld/configure	2016-01-25 09:54:11.000000000 +0100
+++ b/ld/configure	2016-06-05 12:51:34.131313870 +0200
@@ -17134,7 +17134,7 @@
   fi
 done
 
-if test x$ac_default_compressed_debug_sections == xyes ; then
+if test x$ac_default_compressed_debug_sections = xyes ; then
 
 $as_echo "#define DEFAULT_FLAG_COMPRESS_DEBUG 1" >>confdefs.h
 
--- a/ld/configure.ac	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/configure.ac	2016-06-05 12:51:34.132313896 +0200
@@ -384,7 +384,7 @@
   fi
 done
 
-if test x$ac_default_compressed_debug_sections == xyes ; then
+if test x$ac_default_compressed_debug_sections = xyes ; then
   AC_DEFINE(DEFAULT_FLAG_COMPRESS_DEBUG, 1, [Define if you want compressed debug sections by default.])
 fi
 
--- a/ld/emultempl/elf32.em	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/emultempl/elf32.em	2016-06-05 12:51:34.132313896 +0200
@@ -1946,25 +1946,32 @@
       return os;
     }
 
+  flags = s->flags;
+  if (!bfd_link_relocatable (&link_info))
+    {
+      nexts = s;
+      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts))
+	     != NULL)
+	if (nexts->output_section == NULL
+	    && (nexts->flags & SEC_EXCLUDE) == 0
+	    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
+	    && (nexts->owner->flags & DYNAMIC) == 0
+	    && nexts->owner->usrdata != NULL
+	    && !(((lang_input_statement_type *) nexts->owner->usrdata)
+		 ->flags.just_syms)
+	    && _bfd_elf_match_sections_by_type (nexts->owner, nexts,
+						s->owner, s))
+	  flags = (((flags ^ SEC_READONLY)
+		    | (nexts->flags ^ SEC_READONLY))
+		   ^ SEC_READONLY);
+    }
+
   /* Decide which segment the section should go in based on the
      section name and section flags.  We put loadable .note sections
      right after the .interp section, so that the PT_NOTE segment is
      stored right after the program headers where the OS can read it
      in the first page.  */
 
-  flags = s->flags;
-  nexts = s;
-  while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts)) != NULL)
-    if (nexts->output_section == NULL
-	&& (nexts->flags & SEC_EXCLUDE) == 0
-	&& ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
-	&& (nexts->owner->flags & DYNAMIC) == 0
-	&& nexts->owner->usrdata != NULL
-	&& !(((lang_input_statement_type *) nexts->owner->usrdata)
-	     ->flags.just_syms)
-	&& _bfd_elf_match_sections_by_type (nexts->owner, nexts, s->owner, s))
-      flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
-	       ^ SEC_READONLY);
   place = NULL;
   if ((flags & (SEC_ALLOC | SEC_DEBUGGING)) == 0)
     place = &hold[orphan_nonalloc];
--- a/ld/emultempl/mmo.em	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/emultempl/mmo.em	2016-06-05 12:51:34.132313896 +0200
@@ -107,22 +107,28 @@
       return os;
     }
 
+  flags = s->flags;
+  if (!bfd_link_relocatable (&link_info))
+    {
+      nexts = s;
+      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts))
+	     != NULL)
+	if (nexts->output_section == NULL
+	    && (nexts->flags & SEC_EXCLUDE) == 0
+	    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
+	    && (nexts->owner->flags & DYNAMIC) == 0
+	    && nexts->owner->usrdata != NULL
+	    && !(((lang_input_statement_type *) nexts->owner->usrdata)
+		 ->flags.just_syms))
+	  flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
+		   ^ SEC_READONLY);
+    }
+
   /* Check for matching section type flags for sections we care about.
      A section without contents can have SEC_LOAD == 0, but we still
      want it attached to a sane section so the symbols appear as
      expected.  */
-  flags = s->flags;
-  nexts = s;
-  while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts)) != NULL)
-    if (nexts->output_section == NULL
-	&& (nexts->flags & SEC_EXCLUDE) == 0
-	&& ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
-	&& (nexts->owner->flags & DYNAMIC) == 0
-	&& nexts->owner->usrdata != NULL
-	&& !(((lang_input_statement_type *) nexts->owner->usrdata)
-	     ->flags.just_syms))
-      flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
-	       ^ SEC_READONLY);
+
   if ((flags & (SEC_ALLOC | SEC_READONLY)) != SEC_READONLY)
     for (i = 0; i < sizeof (holds) / sizeof (holds[0]); i++)
       if ((flags & holds[i].nonzero_flags) != 0)
--- a/ld/emultempl/pe.em	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/emultempl/pe.em	2016-06-05 12:51:34.133313922 +0200
@@ -2225,21 +2225,27 @@
 	  orphan_init_done = 1;
 	}
 
+      flags = s->flags;
+      if (!bfd_link_relocatable (&link_info))
+	{
+	  nexts = s;
+	  while ((nexts = bfd_get_next_section_by_name (nexts->owner,
+							nexts)))
+	    if (nexts->output_section == NULL
+		&& (nexts->flags & SEC_EXCLUDE) == 0
+		&& ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
+		&& (nexts->owner->flags & DYNAMIC) == 0
+		&& nexts->owner->usrdata != NULL
+		&& !(((lang_input_statement_type *) nexts->owner->usrdata)
+		     ->flags.just_syms))
+	      flags = (((flags ^ SEC_READONLY)
+			| (nexts->flags ^ SEC_READONLY))
+		       ^ SEC_READONLY);
+	}
+
       /* Try to put the new output section in a reasonable place based
 	 on the section name and section flags.  */
 
-      flags = s->flags;
-      nexts = s;
-      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts)))
-	if (nexts->output_section == NULL
-	    && (nexts->flags & SEC_EXCLUDE) == 0
-	    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
-	    && (nexts->owner->flags & DYNAMIC) == 0
-	    && nexts->owner->usrdata != NULL
-	    && !(((lang_input_statement_type *) nexts->owner->usrdata)
-		 ->flags.just_syms))
-	  flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
-		   ^ SEC_READONLY);
       place = NULL;
       if ((flags & SEC_ALLOC) == 0)
 	;
--- a/ld/emultempl/pep.em	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/emultempl/pep.em	2016-06-05 12:51:34.133313922 +0200
@@ -1996,21 +1996,27 @@
 	  orphan_init_done = 1;
 	}
 
+      flags = s->flags;
+      if (!bfd_link_relocatable (&link_info))
+	{
+	  nexts = s;
+	  while ((nexts = bfd_get_next_section_by_name (nexts->owner,
+							nexts)))
+	    if (nexts->output_section == NULL
+		&& (nexts->flags & SEC_EXCLUDE) == 0
+		&& ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
+		&& (nexts->owner->flags & DYNAMIC) == 0
+		&& nexts->owner->usrdata != NULL
+		&& !(((lang_input_statement_type *) nexts->owner->usrdata)
+		     ->flags.just_syms))
+	      flags = (((flags ^ SEC_READONLY)
+			| (nexts->flags ^ SEC_READONLY))
+		       ^ SEC_READONLY);
+	}
+
       /* Try to put the new output section in a reasonable place based
 	 on the section name and section flags.  */
 
-      flags = s->flags;
-      nexts = s;
-      while ((nexts = bfd_get_next_section_by_name (nexts->owner, nexts)))
-	if (nexts->output_section == NULL
-	    && (nexts->flags & SEC_EXCLUDE) == 0
-	    && ((nexts->flags ^ flags) & (SEC_LOAD | SEC_ALLOC)) == 0
-	    && (nexts->owner->flags & DYNAMIC) == 0
-	    && nexts->owner->usrdata != NULL
-	    && !(((lang_input_statement_type *) nexts->owner->usrdata)
-		 ->flags.just_syms))
-	  flags = (((flags ^ SEC_READONLY) | (nexts->flags ^ SEC_READONLY))
-		   ^ SEC_READONLY);
       place = NULL;
       if ((flags & SEC_ALLOC) == 0)
 	;
--- a/ld/lexsup.c	2015-11-13 09:27:42.000000000 +0100
+++ b/ld/lexsup.c	2016-06-05 12:51:34.133313922 +0200
@@ -1586,15 +1586,14 @@
   /* We may have -Bsymbolic, -Bsymbolic-functions, --dynamic-list-data,
      --dynamic-list-cpp-new, --dynamic-list-cpp-typeinfo and
      --dynamic-list FILE.  -Bsymbolic and -Bsymbolic-functions are
-     for shared libraries.  -Bsymbolic overrides all others and vice
-     versa.  */
+     for PIC outputs.  -Bsymbolic overrides all others and vice versa.  */
   switch (command_line.symbolic)
     {
     case symbolic_unset:
       break;
     case symbolic:
-      /* -Bsymbolic is for shared library only.  */
-      if (bfd_link_dll (&link_info))
+      /* -Bsymbolic is for PIC output only.  */
+      if (bfd_link_pic (&link_info))
 	{
 	  link_info.symbolic = TRUE;
 	  /* Should we free the unused memory?  */
@@ -1603,8 +1602,8 @@
 	}
       break;
     case symbolic_functions:
-      /* -Bsymbolic-functions is for shared library only.  */
-      if (bfd_link_dll (&link_info))
+      /* -Bsymbolic-functions is for PIC output only.  */
+      if (bfd_link_pic (&link_info))
 	command_line.dynamic_list = dynamic_list_data;
       break;
     }
--- a/opcodes/i386-dis.c	2016-01-25 09:51:06.000000000 +0100
+++ b/opcodes/i386-dis.c	2016-06-05 12:51:34.135313973 +0200
@@ -13644,7 +13644,7 @@
     if (op_index[i] != -1 && op_riprel[i])
       {
 	(*info->fprintf_func) (info->stream, "        # ");
-	(*info->print_address_func) ((bfd_vma) (start_pc + codep - start_codep
+	(*info->print_address_func) ((bfd_vma) (start_pc + (codep - start_codep)
 						+ op_address[op_index[i]]), info);
 	break;
       }
@@ -16158,7 +16158,7 @@
 	     the displacement is added!  */
 	  mask = 0xffff;
 	  if ((prefixes & PREFIX_DATA) == 0)
-	    segment = ((start_pc + codep - start_codep)
+	    segment = ((start_pc + (codep - start_codep))
 		       & ~((bfd_vma) 0xffff));
 	}
       if (address_mode != mode_64bit
