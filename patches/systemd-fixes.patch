--- a/src/bus-proxyd/bus-xml-policy.c	2015-05-11 22:39:42.776164939 +0200
+++ b/src/bus-proxyd/bus-xml-policy.c	2015-07-05 13:17:10.350372292 +0200
@@ -301,7 +301,7 @@
                                         ic = POLICY_ITEM_USER;
                                 else if (streq(name, "group"))
                                         ic = POLICY_ITEM_GROUP;
-                                else if (streq(name, "eavesdrop")) {
+                                else if (STR_IN_SET(name, "eavesdrop", "log")) {
                                         log_debug("Unsupported attribute %s= at %s:%u, ignoring.", name, path, line);
                                         state = STATE_ALLOW_DENY_OTHER_ATTRIBUTE;
                                         break;
--- a/src/bus-proxyd/proxy.c	2015-06-18 00:28:41.596640634 +0200
+++ b/src/bus-proxyd/proxy.c	2015-07-05 13:20:03.211604056 +0200
@@ -494,7 +494,16 @@
                 }
 
                 /* First check if we (the sender) can send to this name */
-                if (policy_check_send(policy, our_ucred->uid, our_ucred->gid, m->header->type, NULL, destination_names, m->path, m->interface, m->member, true, &n)) {
+                if (sd_bus_message_is_signal(m, NULL, NULL)) {
+                        /* If we forward a signal from dbus-1 to kdbus, we have
+                         * no idea who the recipient is. Therefore, we cannot
+                         * apply any dbus-1 policies that match on receiver
+                         * credentials. We know sd-bus always sets
+                         * KDBUS_MSG_SIGNAL, so the kernel applies policies to
+                         * the message. Therefore, skip policy checks in this
+                         * case. */
+                        return 0;
+                } else if (policy_check_send(policy, our_ucred->uid, our_ucred->gid, m->header->type, NULL, destination_names, m->path, m->interface, m->member, true, &n)) {
                         if (n) {
                                 /* If we made a receiver decision, then remember which
                                  * name's policy we used, and to which unique ID it
@@ -512,19 +521,8 @@
                                         return r;
                         }
 
-                        if (sd_bus_message_is_signal(m, NULL, NULL)) {
-                                /* If we forward a signal from dbus-1 to kdbus,
-                                 * we have no idea who the recipient is.
-                                 * Therefore, we cannot apply any dbus-1
-                                 * receiver policies that match on receiver
-                                 * credentials. We know sd-bus always sets
-                                 * KDBUS_MSG_SIGNAL, so the kernel applies
-                                 * receiver policies to the message. Therefore,
-                                 * skip policy checks in this case. */
+                        if (policy_check_recv(policy, destination_uid, destination_gid, m->header->type, owned_names, NULL, m->path, m->interface, m->member, true))
                                 return 0;
-                        } else if (policy_check_recv(policy, destination_uid, destination_gid, m->header->type, owned_names, NULL, m->path, m->interface, m->member, true)) {
-                                return 0;
-                        }
                 }
 
                 /* Return an error back to the caller */
--- a/src/core/dbus.c	2015-05-11 22:39:42.810164941 +0200
+++ b/src/core/dbus.c	2015-07-05 13:21:32.568305045 +0200
@@ -69,13 +69,37 @@
 }
 
 static int signal_agent_released(sd_bus_message *message, void *userdata, sd_bus_error *error) {
+        _cleanup_bus_creds_unref_ sd_bus_creds *creds = NULL;
+        const char *cgroup, *me;
         Manager *m = userdata;
-        const char *cgroup;
+        uid_t sender_uid;
+        sd_bus *bus;
         int r;
 
         assert(message);
         assert(m);
 
+        /* ignore recursive events sent by us on the system/user bus */
+        bus = sd_bus_message_get_bus(message);
+        if (!sd_bus_is_server(bus)) {
+                r = sd_bus_get_unique_name(bus, &me);
+                if (r < 0)
+                        return r;
+
+                if (streq_ptr(sd_bus_message_get_sender(message), me))
+                        return 0;
+        }
+
+        /* only accept org.freedesktop.systemd1.Agent from UID=0 */
+        r = sd_bus_query_sender_creds(message, SD_BUS_CREDS_EUID, &creds);
+        if (r < 0)
+                return r;
+
+        r = sd_bus_creds_get_euid(creds, &sender_uid);
+        if (r < 0 || sender_uid != 0)
+                return 0;
+
+        /* parse 'cgroup-empty' notification */
         r = sd_bus_message_read(message, "s", &cgroup);
         if (r < 0) {
                 bus_log_parse_error(r);
@@ -84,19 +108,15 @@
 
         manager_notify_cgroup_empty(m, cgroup);
 
-        /* only forward to system bus if running as system instance */
-        if (m->running_as != MANAGER_SYSTEM || !m->system_bus)
-                return 0;
-
-        r = sd_bus_message_rewind(message, 1);
-        if (r < 0)
-                goto exit;
-
-        r = sd_bus_send(m->system_bus, message, NULL);
+        /* if running as system-instance, forward under our name */
+        if (m->running_as == MANAGER_SYSTEM && m->system_bus) {
+                r = sd_bus_message_rewind(message, 1);
+                if (r >= 0)
+                        r = sd_bus_send(m->system_bus, message, NULL);
+                if (r < 0)
+                        log_warning_errno(r, "Failed to forward Released message: %m");
+        }
 
-exit:
-        if (r < 0)
-                log_warning_errno(r, "Failed to forward Released message: %m");
         return 0;
 }
 
--- a/src/core/mount-setup.c	2015-06-17 20:28:29.557344895 +0200
+++ b/src/core/mount-setup.c	2015-07-05 13:22:07.856981479 +0200
@@ -27,6 +27,7 @@
 
 #include "mount-setup.h"
 #include "dev-setup.h"
+#include "bus-util.h"
 #include "log.h"
 #include "macro.h"
 #include "util.h"
@@ -105,7 +106,7 @@
           is_efi_boot,   MNT_NONE                   },
 #endif
         { "kdbusfs",    "/sys/fs/kdbus",             "kdbusfs",    NULL, MS_NOSUID|MS_NOEXEC|MS_NODEV,
-          NULL,       MNT_IN_CONTAINER },
+          is_kdbus_wanted,       MNT_IN_CONTAINER },
 };
 
 /* These are API file systems that might be mounted by other software,
--- a/src/core/unit.c	2015-06-11 12:13:57.959575418 +0200
+++ b/src/core/unit.c	2015-07-05 13:23:51.211975796 +0200
@@ -1596,7 +1596,7 @@
         static const UnitDependency needed_dependencies[] = {
                 UNIT_REQUIRED_BY,
                 UNIT_REQUIRED_BY_OVERRIDABLE,
-                UNIT_REQUISITE,
+                UNIT_REQUISITE_OF,
                 UNIT_REQUISITE_OF_OVERRIDABLE,
                 UNIT_WANTED_BY,
                 UNIT_BOUND_BY,
--- a/src/libsystemd/sd-bus/bus-kernel.c	2015-06-17 20:27:50.860877493 +0200
+++ b/src/libsystemd/sd-bus/bus-kernel.c	2015-07-05 13:20:35.775221847 +0200
@@ -1385,15 +1385,16 @@
                         r = 0;
                 }
 
-        } else if (k->payload_type == KDBUS_PAYLOAD_KERNEL)
+                if (r <= 0)
+                        close_kdbus_msg(bus, k);
+        } else if (k->payload_type == KDBUS_PAYLOAD_KERNEL) {
                 r = bus_kernel_translate_message(bus, k);
-        else {
+                close_kdbus_msg(bus, k);
+        } else {
                 log_debug("Ignoring message with unknown payload type %llu.", (unsigned long long) k->payload_type);
                 r = 0;
-        }
-
-        if (r <= 0)
                 close_kdbus_msg(bus, k);
+        }
 
         return r < 0 ? r : 1;
 }
--- a/src/login/logind.c	2015-06-17 20:27:50.868877594 +0200
+++ b/src/login/logind.c	2015-07-05 13:18:16.646601367 +0200
@@ -1109,6 +1109,12 @@
 
                 manager_gc(m, true);
 
+                r = manager_dispatch_delayed(m, false);
+                if (r < 0)
+                        return r;
+                if (r > 0)
+                        continue;
+
                 r = sd_event_run(m->event, (uint64_t) -1);
                 if (r < 0)
                         return r;
--- a/src/login/logind-dbus.c	2015-06-17 20:27:50.867877581 +0200
+++ b/src/login/logind-dbus.c	2015-07-05 13:19:43.656234290 +0200
@@ -690,6 +690,8 @@
         }
 
         manager_get_session_by_pid(m, leader, &session);
+        if (!session && vtnr > 0)
+                session = (vtnr < m->seat0->position_count) ? m->seat0->positions[vtnr] : NULL;
         if (session) {
                 _cleanup_free_ char *path = NULL;
                 _cleanup_close_ int fifo_fd = -1;
@@ -1486,18 +1488,13 @@
         return 0;
 }
 
-static int manager_inhibit_timeout_handler(
-                        sd_event_source *s,
-                        uint64_t usec,
-                        void *userdata) {
+int manager_dispatch_delayed(Manager *manager, bool timeout) {
 
         _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;
         Inhibitor *offending = NULL;
-        Manager *manager = userdata;
         int r;
 
         assert(manager);
-        assert(manager->inhibit_timeout_source == s);
 
         if (manager->action_what == 0 || manager->action_job)
                 return 0;
@@ -1505,6 +1502,9 @@
         if (manager_is_inhibited(manager, manager->action_what, INHIBIT_DELAY, NULL, false, false, 0, &offending)) {
                 _cleanup_free_ char *comm = NULL, *u = NULL;
 
+                if (!timeout)
+                        return 0;
+
                 (void) get_process_comm(offending->pid, &comm);
                 u = uid_to_name(offending->uid);
 
@@ -1520,9 +1520,25 @@
 
                 manager->action_unit = NULL;
                 manager->action_what = 0;
+                return r;
         }
 
-        return 0;
+        return 1;
+}
+
+static int manager_inhibit_timeout_handler(
+                        sd_event_source *s,
+                        uint64_t usec,
+                        void *userdata) {
+
+        Manager *manager = userdata;
+        int r;
+
+        assert(manager);
+        assert(manager->inhibit_timeout_source == s);
+
+        r = manager_dispatch_delayed(manager, true);
+        return (r < 0) ? r : 0;
 }
 
 static int delay_shutdown_or_sleep(
--- a/src/login/logind.h	2015-06-17 20:27:50.868877594 +0200
+++ b/src/login/logind.h	2015-07-05 13:18:16.646601367 +0200
@@ -194,3 +194,5 @@
 
 int manager_setup_wall_message_timer(Manager *m);
 bool logind_wall_tty_filter(const char *tty, void *userdata);
+
+int manager_dispatch_delayed(Manager *manager, bool timeout);
--- a/src/login/pam_systemd.c	2015-06-17 20:28:29.559344918 +0200
+++ b/src/login/pam_systemd.c	2015-07-05 13:14:36.891588696 +0200
@@ -181,7 +181,7 @@
         int r;
 
         /* skip export if kdbus is not active */
-        if (access("/sys/fs/kdbus", F_OK) < 0)
+        if (!is_kdbus_available())
                 return PAM_SUCCESS;
 
         if (asprintf(&s, KERNEL_USER_BUS_ADDRESS_FMT ";" UNIX_USER_BUS_ADDRESS_FMT, uid, runtime) < 0) {
--- a/src/udev/udevadm-trigger.c	2015-05-11 22:39:43.691164988 +0200
+++ b/src/udev/udevadm-trigger.c	2015-07-05 13:16:52.019035022 +0200
@@ -116,7 +116,7 @@
         } device_type = TYPE_DEVICES;
         const char *action = "change";
         _cleanup_udev_enumerate_unref_ struct udev_enumerate *udev_enumerate = NULL;
-        int c;
+        int c, r;
 
         udev_enumerate = udev_enumerate_new(udev);
         if (udev_enumerate == NULL)
@@ -153,28 +153,56 @@
 
                         break;
                 case 's':
-                        udev_enumerate_add_match_subsystem(udev_enumerate, optarg);
+                        r = udev_enumerate_add_match_subsystem(udev_enumerate, optarg);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add subsystem match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 case 'S':
-                        udev_enumerate_add_nomatch_subsystem(udev_enumerate, optarg);
+                        r = udev_enumerate_add_nomatch_subsystem(udev_enumerate, optarg);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add negative subsystem match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 case 'a':
                         key = keyval(optarg, &val, buf, sizeof(buf));
-                        udev_enumerate_add_match_sysattr(udev_enumerate, key, val);
+                        r = udev_enumerate_add_match_sysattr(udev_enumerate, key, val);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add sysattr match '%s=%s': %m", key, val);
+                                return 2;
+                        }
                         break;
                 case 'A':
                         key = keyval(optarg, &val, buf, sizeof(buf));
-                        udev_enumerate_add_nomatch_sysattr(udev_enumerate, key, val);
+                        r = udev_enumerate_add_nomatch_sysattr(udev_enumerate, key, val);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add negative sysattr match '%s=%s': %m", key, val);
+                                return 2;
+                        }
                         break;
                 case 'p':
                         key = keyval(optarg, &val, buf, sizeof(buf));
-                        udev_enumerate_add_match_property(udev_enumerate, key, val);
+                        r = udev_enumerate_add_match_property(udev_enumerate, key, val);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add property match '%s=%s': %m", key, val);
+                                return 2;
+                        }
                         break;
                 case 'g':
-                        udev_enumerate_add_match_tag(udev_enumerate, optarg);
+                        r = udev_enumerate_add_match_tag(udev_enumerate, optarg);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add tag match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 case 'y':
-                        udev_enumerate_add_match_sysname(udev_enumerate, optarg);
+                        r = udev_enumerate_add_match_sysname(udev_enumerate, optarg);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add sysname match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 case 'b': {
                         _cleanup_udev_device_unref_ struct udev_device *dev;
@@ -185,7 +213,11 @@
                                 return 2;
                         }
 
-                        udev_enumerate_add_match_parent(udev_enumerate, dev);
+                        r = udev_enumerate_add_match_parent(udev_enumerate, dev);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add parent match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 }
 
@@ -198,7 +230,11 @@
                                 return 2;
                         }
 
-                        udev_enumerate_add_match_parent(udev_enumerate, dev);
+                        r = udev_enumerate_add_match_parent(udev_enumerate, dev);
+                        if (r < 0) {
+                                log_error_errno(r, "could not add parent match '%s': %m", optarg);
+                                return 2;
+                        }
                         break;
                 }
 
@@ -221,7 +257,11 @@
                         return 2;
                 }
 
-                udev_enumerate_add_match_parent(udev_enumerate, dev);
+                r = udev_enumerate_add_match_parent(udev_enumerate, dev);
+                if (r < 0) {
+                        log_error_errno(r, "could not add tag match '%s': %m", optarg);
+                        return 2;
+                }
         }
 
         switch (device_type) {
--- a/src/udev/udev-builtin-hwdb.c	2015-06-09 01:06:17.193812961 +0200
+++ b/src/udev/udev-builtin-hwdb.c	2015-07-05 13:15:43.208780024 +0200
@@ -26,6 +26,7 @@
 #include "sd-hwdb.h"
 
 #include "hwdb-util.h"
+#include "udev-util.h"
 
 static sd_hwdb *hwdb;
 
@@ -87,6 +88,9 @@
 
         assert(dev);
 
+        if (!srcdev)
+                srcdev = dev;
+
         for (d = srcdev; d && !last; d = udev_device_get_parent(d)) {
                 const char *dsubsys;
                 const char *modalias = NULL;
@@ -133,7 +137,7 @@
         const char *device = NULL;
         const char *subsystem = NULL;
         const char *prefix = NULL;
-        struct udev_device *srcdev;
+        _cleanup_udev_device_unref_ struct udev_device *srcdev = NULL;
 
         if (!hwdb)
                 return EXIT_FAILURE;
@@ -176,8 +180,7 @@
                 srcdev = udev_device_new_from_device_id(udev_device_get_udev(dev), device);
                 if (!srcdev)
                         return EXIT_FAILURE;
-        } else
-                srcdev = dev;
+        }
 
         if (udev_builtin_hwdb_search(dev, srcdev, subsystem, prefix, filter, test) > 0)
                 return EXIT_SUCCESS;
--- a/src/udev/udevd.c	2015-06-17 23:29:40.551778702 +0200
+++ b/src/udev/udevd.c	2015-07-05 13:20:16.377853541 +0200
@@ -327,6 +327,7 @@
         struct udev *udev = event->udev;
         _cleanup_udev_monitor_unref_ struct udev_monitor *worker_monitor = NULL;
         pid_t pid;
+        int r = 0;
 
         /* listen for new events */
         worker_monitor = udev_monitor_new_from_netlink(udev, NULL);
@@ -334,7 +335,9 @@
                 return;
         /* allow the main daemon netlink address to send devices to the worker */
         udev_monitor_allow_unicast_sender(worker_monitor, manager->monitor);
-        udev_monitor_enable_receiving(worker_monitor);
+        r = udev_monitor_enable_receiving(worker_monitor);
+        if (r < 0)
+                log_error_errno(r, "worker: could not enable receiving of device: %m");
 
         pid = fork();
         switch (pid) {
@@ -346,7 +349,6 @@
                 struct epoll_event ep_signal = { .events = EPOLLIN };
                 struct epoll_event ep_monitor = { .events = EPOLLIN };
                 sigset_t mask;
-                int r = 0;
 
                 /* take initial device from queue */
                 dev = event->dev;
@@ -528,7 +530,6 @@
         default:
         {
                 struct worker *worker;
-                int r;
 
                 r = worker_new(&worker, manager, worker_monitor, pid);
                 if (r < 0)
@@ -1607,8 +1608,42 @@
         return 0;
 }
 
-int main(int argc, char *argv[]) {
+static int run(int fd_ctrl, int fd_uevent, const char *cgroup) {
         _cleanup_(manager_freep) Manager *manager = NULL;
+        int r;
+
+        r = manager_new(&manager, fd_ctrl, fd_uevent, cgroup);
+        if (r < 0) {
+                r = log_error_errno(r, "failed to allocate manager object: %m");
+                goto exit;
+        }
+
+        r = udev_rules_apply_static_dev_perms(manager->rules);
+        if (r < 0)
+                log_error_errno(r, "failed to apply permissions on static device nodes: %m");
+
+        (void) sd_notify(false,
+                         "READY=1\n"
+                         "STATUS=Processing...");
+
+        r = sd_event_loop(manager->event);
+        if (r < 0) {
+                log_error_errno(r, "event loop failed: %m");
+                goto exit;
+        }
+
+        sd_event_get_exit_code(manager->event, &r);
+
+exit:
+        sd_notify(false,
+                  "STOPPING=1\n"
+                  "STATUS=Shutting down...");
+        if (manager)
+                udev_ctrl_cleanup(manager->ctrl);
+        return r;
+}
+
+int main(int argc, char *argv[]) {
         _cleanup_free_ char *cgroup = NULL;
         int r, fd_ctrl, fd_uevent;
 
@@ -1709,35 +1744,9 @@
                 write_string_file("/proc/self/oom_score_adj", "-1000");
         }
 
-        r = manager_new(&manager, fd_ctrl, fd_uevent, cgroup);
-        if (r < 0) {
-                r = log_error_errno(r, "failed to allocate manager object: %m");
-                goto exit;
-        }
-
-        r = udev_rules_apply_static_dev_perms(manager->rules);
-        if (r < 0)
-                log_error_errno(r, "failed to apply permissions on static device nodes: %m");
-
-        (void) sd_notify(false,
-                         "READY=1\n"
-                         "STATUS=Processing...");
-
-        r = sd_event_loop(manager->event);
-        if (r < 0) {
-                log_error_errno(r, "event loop failed: %m");
-                goto exit;
-        }
-
-        sd_event_get_exit_code(manager->event, &r);
+        r = run(fd_ctrl, fd_uevent, cgroup);
 
 exit:
-        sd_notify(false,
-                  "STOPPING=1\n"
-                  "STATUS=Shutting down...");
-
-        if (manager)
-                udev_ctrl_cleanup(manager->ctrl);
         mac_selinux_finish();
         log_close();
         return r < 0 ? EXIT_FAILURE : EXIT_SUCCESS;
--- a/src/udev/udev-event.c	2015-06-17 20:27:50.880877745 +0200
+++ b/src/udev/udev-event.c	2015-07-05 13:16:07.536221652 +0200
@@ -389,26 +389,44 @@
                       const char *cmd, char *const argv[], char **envp,
                       int fd_stdout, int fd_stderr) {
         _cleanup_close_ int fd = -1;
+        int r;
 
         /* discard child output or connect to pipe */
         fd = open("/dev/null", O_RDWR);
         if (fd >= 0) {
-                dup2(fd, STDIN_FILENO);
-                if (fd_stdout < 0)
-                        dup2(fd, STDOUT_FILENO);
-                if (fd_stderr < 0)
-                        dup2(fd, STDERR_FILENO);
+                r = dup2(fd, STDIN_FILENO);
+                if (r < 0)
+                        log_warning_errno(errno, "redirecting stdin failed: %m");
+
+                if (fd_stdout < 0) {
+                        r = dup2(fd, STDOUT_FILENO);
+                        if (r < 0)
+                                log_warning_errno(errno, "redirecting stdout failed: %m");
+                }
+
+                if (fd_stderr < 0) {
+                        r = dup2(fd, STDERR_FILENO);
+                        if (r < 0)
+                                log_warning_errno(errno, "redirecting stderr failed: %m");
+                }
         } else
-                log_error_errno(errno, "open /dev/null failed: %m");
+                log_warning_errno(errno, "open /dev/null failed: %m");
 
         /* connect pipes to std{out,err} */
         if (fd_stdout >= 0) {
-                dup2(fd_stdout, STDOUT_FILENO);
-                safe_close(fd_stdout);
+                r = dup2(fd_stdout, STDOUT_FILENO);
+                if (r < 0)
+                        log_warning_errno(errno, "redirecting stdout failed: %m");
+
+                fd_stdout = safe_close(fd_stdout);
         }
+
         if (fd_stderr >= 0) {
-                dup2(fd_stderr, STDERR_FILENO);
-                safe_close(fd_stderr);
+                r = dup2(fd_stderr, STDERR_FILENO);
+                if (r < 0)
+                        log_warning_errno(errno, "redirecting stdout failed: %m");
+
+                fd_stderr = safe_close(fd_stderr);
         }
 
         /* terminate child in case parent goes away */
