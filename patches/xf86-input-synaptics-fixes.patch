--- a/src/eventcomm.c	2016-04-27 01:29:23.000000000 +0200
+++ b/src/eventcomm.c	2016-09-20 22:51:03.289442402 +0200
@@ -1009,13 +1009,13 @@
 
             if (!(pInfo->flags & XI86_SERVER_FD))
                 SYSCALL(close(fd));
-
-            /* if a device is set and not a touchpad (or already grabbed),
-             * we must return FALSE.  Otherwise, we'll add a device that
-             * wasn't requested for and repeat
-             * f5687a6741a19ef3081e7fd83ac55f6df8bcd5c2. */
-            return touchpad_found;
         }
+
+        /* if a device is set and not a touchpad (or already grabbed),
+         * we must return FALSE.  Otherwise, we'll add a device that
+         * wasn't requested for and repeat
+         * f5687a6741a19ef3081e7fd83ac55f6df8bcd5c2. */
+        return touchpad_found;
     }
 
     i = scandir(DEV_INPUT_EVENT, &namelist, EventDevOnly, alphasort);
--- a/src/synaptics.c	2015-11-25 07:28:43.000000000 +0100
+++ b/src/synaptics.c	2016-09-20 22:51:42.831686984 +0200
@@ -671,7 +671,7 @@
     pars->finger_high = xf86SetIntOption(opts, "FingerHigh", fingerHigh);
     pars->tap_time = xf86SetIntOption(opts, "MaxTapTime", 180);
     pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", tapMove);
-    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 100);
+    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
     pars->click_time = xf86SetIntOption(opts, "ClickTime", 100);
     pars->clickpad = xf86SetBoolOption(opts, "ClickPad", pars->clickpad);       /* Probed */
     if (pars->clickpad)
@@ -1601,9 +1601,11 @@
     SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
     struct SynapticsHwState *hw = priv->local_hw_state;
     int delay;
-    int sigstate;
-
-    sigstate = xf86BlockSIGIO();
+#if !HAVE_THREADED_INPUT
+    int sigstate = xf86BlockSIGIO();
+#else
+    input_lock();
+#endif
 
     priv->hwState->millis += now - priv->timer_time;
     SynapticsCopyHwState(hw, priv->hwState);
@@ -1613,7 +1615,11 @@
     priv->timer_time = now;
     priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
 
+#if !HAVE_THREADED_INPUT
     xf86UnblockSIGIO(sigstate);
+#else
+    input_unlock();
+#endif
 
     return 0;
 }
--- a/src/synapticsstr.h	2015-11-25 07:28:43.000000000 +0100
+++ b/src/synapticsstr.h	2016-09-20 22:51:42.831686984 +0200
@@ -36,6 +36,10 @@
 #define NO_DRIVER_SCALING 1
 #endif
 
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 23
+#define HAVE_THREADED_INPUT 1
+#endif
+
 #ifdef DBG
 #undef DBG
 #endif
--- a/tools/syndaemon.c	2015-11-25 00:46:19.000000000 +0100
+++ b/tools/syndaemon.c	2016-09-20 22:51:16.688525034 +0200
@@ -47,6 +47,12 @@
 
 #include "synaptics-properties.h"
 
+enum KeyboardActivity {
+    ActivityNew,
+    ActivityNone,
+    ActivityReset
+};
+
 enum TouchpadState {
     TouchpadOn = 0,
     TouchpadOff = 1,
@@ -181,29 +187,29 @@
     }
 }
 
-/**
- * Return non-zero if the keyboard state has changed since the last call.
- */
-static int
+static enum KeyboardActivity
 keyboard_activity(Display * display)
 {
     static unsigned char old_key_state[KEYMAP_SIZE];
     unsigned char key_state[KEYMAP_SIZE];
     int i;
-    int ret = 0;
+    int ret = ActivityNone;
 
     XQueryKeymap(display, (char *) key_state);
 
     for (i = 0; i < KEYMAP_SIZE; i++) {
         if ((key_state[i] & ~old_key_state[i]) & keyboard_mask[i]) {
-            ret = 1;
+            ret = ActivityNew;
             break;
         }
     }
     if (ignore_modifier_combos) {
         for (i = 0; i < KEYMAP_SIZE; i++) {
             if (key_state[i] & ~keyboard_mask[i]) {
-                ret = 0;
+                if (old_key_state[i] & ~keyboard_mask[i])
+                    ret = ActivityNone;
+                else
+                    ret = ActivityReset;
                 break;
             }
         }
@@ -232,8 +238,17 @@
 
     for (;;) {
         current_time = get_time();
-        if (keyboard_activity(display))
-            last_activity = current_time;
+        switch (keyboard_activity(display)) {
+            case ActivityNew:
+                last_activity = current_time;
+                break;
+            case ActivityNone:
+                /* NOP */;
+                break;
+            case ActivityReset:
+                last_activity = 0.0;
+                break;
+        }
 
         /* If system times goes backwards, touchpad can get locked. Make
          * sure our last activity wasn't in the future and reset if it was. */
@@ -423,6 +438,7 @@
         fd_set read_fds;
         int ret;
         int disable_event = 0;
+        int modifier_event = 0;
         struct timeval timeout;
 
         FD_ZERO(&read_fds);
@@ -454,9 +470,14 @@
                 disable_event = 1;
             }
 
-            if (cbres.non_modifier_event &&
-                !(ignore_modifier_combos && is_modifier_pressed(&cbres))) {
-                disable_event = 1;
+            if (cbres.non_modifier_event) {
+                if (ignore_modifier_combos && is_modifier_pressed(&cbres)) {
+                    modifier_event = 1;
+                } else {
+                    disable_event = 1;
+                }
+            } else if (ignore_modifier_keys) {
+                modifier_event = 1;
             }
         }
 
@@ -468,10 +489,13 @@
             toggle_touchpad(False);
         }
 
-        if (ret == 0 && pad_disabled) { /* timeout => enable event */
+        if (modifier_event && pad_disabled) {
             toggle_touchpad(True);
         }
 
+        if (ret == 0 && pad_disabled) { /* timeout => enable event */
+            toggle_touchpad(True);
+        }
     }                           /* end while(1) */
 
     XFreeModifiermap(cbres.modifiers);
